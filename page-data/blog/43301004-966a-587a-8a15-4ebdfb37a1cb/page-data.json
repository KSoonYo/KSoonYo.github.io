{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/43301004-966a-587a-8a15-4ebdfb37a1cb/","result":{"data":{"site":{"siteMetadata":{"title":"KSoonYo Blog"}},"notionPage":{"title":"[Javascript] .then과 .catch가 여러 개일 때에 대한 케이스 실험","contentHtml":"<p></p><h1><span>Case 1: 비동기와 then, catch</span></h1><p><strong><span>같은 시간의 타이머를 가진 Promise 객체 A가 있다고 가정</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})</span></code></pre><p></p><p></p><p><strong><span>아래와 같이 </span></strong><code><strong><span>then</span></strong></code><strong><span> 과 </span></strong><code><strong><span>catch</span></strong></code><strong><span> 를 chaining을 할 때 결과는?</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">a.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nPromise A rejected!\nYes, it's resolved\nNo, it's rejected</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved</span></code></pre><p></p><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved\nPromise A rejected!</span></code></pre><p></p><p><span>정답은 3번</span></p><p></p><p><span>해설</span></p><li><span>setTimeout은 대표적인 비동기 함수</span><ul></ul></li><li><span>비동기 프로세스와 이벤트 루프에 의해 setTimeout이 처리되는 순서대로 호출된다.</span><ul></ul></li><li><span>위 예시에서는 Promise A를 resolve 처리한 함수가 먼저 호출되었다.</span><ul></ul></li><li><span>Promise A가 resolved 됨에 따라 then이 호출된다.</span><ul></ul></li><li><span>이후에 Promise A를 reject하는 함수가 호출되었으나, Promise A는 이미 상태가 </span><code><span>pending</span></code><span> 상태에서 </span><code><span>fullfilled</span></code><span> 상태가 되었으므로 Promise의 상태가 변경되지 않는다. → 따라서 catch 함수는 실행되지 않는다.</span><ul></ul></li><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/c0f702ff-a014-4f0e-ad20-182338fa1b2b/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=3f6698912732865264f1fc496ecf861429a70672e47133c5a0b1c8de218769dc&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>→ 만약 rejected되는 함수의 타이머 시간을 줄이면 어떻게 될까?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 100)\n})\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>결과는 아래와 같다.</span></p><pre class=\"language-shell\"><code class=\"language-shell\"><span>Promise A rejected!\nNo, it's rejected\nPromise A resolved!</span></code></pre><p></p><p><span>만약 then 함수 안에서 a를 console.log로 찍어보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n  console.log('printed a: ', a) // a 출력\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>fullfilled된 상태의 a가 출력된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/edaca4d6-2384-472b-a167-66bb70967434/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=eda42af2be14b4dd7d344fe7080c6f36e9aed45c87e8cc71ae97991615b7e6b3&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>resolved된 Promise A 객체를 </span><code><span>reject()</span></code><span> 호출 후에 확인해보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n    console.log('printed a: ', a) // a 출력\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p><span>역시나 </span><code><span>fullfilled</span></code><span> 상태의 Promise가 출력된다. 즉 이미 상태가 결정된 Promise는 다른 상태로 변경되지 않는다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7db5d987-e279-471d-9054-d17a32d53c70/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=208cd78e9cc6ccceb48d6f7696e058b91af114709f97ea7d107f198fe30d3468&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><h1><span>Case2: then chain의 error catch 도달 범위</span></h1><p><span>실습 환경: javascript playground</span></p><p><a href=\"https://playcode.io/javascript\">https://playcode.io/javascript</a></p><p><a href=\"https://www.jsplayground.dev/\">https://www.jsplayground.dev/</a></p><p></p><p><span>아래와 같은 Promise 객체가 있고, 여러 개의 </span><code><span>then</span></code><span>  chain이 있다고 가정</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n  .catch(e = console.error(e))\n})\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>그리고 두번째 then chain 부분에 catch chain을 추가</span></p><p></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e)) // catch 문 추가!\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n</span></code></pre><p><span>과연 어떤 에러 문구가 출력이 될까?</span></p><p></p><p><span>정답</span></p><p></p><p><span>그리고 다시 catch 문을 추가해보자. 기존 catch문 바로 아래에 추가</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e))\n.catch(e = console.error(e)) // 두번째 catch 블록\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 </span><code><span>The second Error!</span></code><span> 가 출력이 될까? </span></p><p><span>→ 안된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/125f52e8-2725-4777-aa71-f5ef412e67be/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=d137e69cd043b68ca5cef5e387c6775bf4d4528e5f108bed84e1d6c17ba8cafd&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>원인) 이미 상태가 결정된 Promise는 다른 상태로 전이되지 않는다는 특성 때문</span></p><p><span>따라서 첫번재 then에서 발생한 에러에 의해 then이 반환한 Promise는 rejected 상태가 되고, 체이닝에서 가장 첫번째 catch 블록으로 이동하여 콜백이 실행된다. 해당 catch 블록에서는 더이상 다른 Promise를 반환하지 않으므로 두번째 .then으로 Promise가 실행되지 않는다.</span></p><p></p><p><span>그렇다면 catch 블록 안에서 또 에러를 발생시켜보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error('Here is the first catch block')\n  throw new Error(`Passed Error: ${e} from the first catch block`) // nested Error throwing!\n})\n.catch(e = console.error(e))\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 에러 문구가 출력되는 것을 확인할 수 있다.</span></p><p></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/aef4f0d9-9372-4f89-97cf-5ea6ee40e841/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=8dcc519c91cbee855b485b7c7f867cf248686fd4f2b65456b92bce7b0e659852&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>이번에는 두번째 catch 블록을 지우고 catch 블록에서 resolve 상태의 Promise를 리턴해보자. 그리고 catch 문에는 then 체인이 걸려있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.resolve() // resolved 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})</span></code></pre><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/df0b0551-19e1-42a8-8d5b-2d23f69f5ddd/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=188a015850ca284fc3f5a9015f5e7693edc279cfddfc7f8cc49473d95e3a0b57&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>세번째 then 체인이 실행되는 것을 확인할 수 있다.</span></p><p><span>rejected 상태의 Promise는 어떨까? 해당 Promise 객체를 반환하는 다음 체이닝에 catch 블록이 있다고 가정해본다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') // rejected 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e) // 에러 문구 출력\n})\n</span></code></pre><p></p><p><span>rejected Promise의 에러 문구 내용이 마지막 catch 블록에서 실행되는 것을 확인할 수 있다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/30371ba4-15ab-415d-a91f-25d28b1354e9/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=b8fdf741cd7a0577cea03ae5265cc5766143e8d7f1a002e8a6678c6400fe5110&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><p><span>이제 여러 개의 catch 블록과 여러 개의 then 순서를 뒤바꾸면 코드가 매우 흥미로워진다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.catch(e = console.error(e))\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') \n})\n.then(() = {\n  console.log('This is the second then block')\n  throw new Error('The second Error!')\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e)\n})\n</span></code></pre><p><span>실행 결과는 어떻게 될까?</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7ca64e89-baac-499d-a49b-0216fcb4776f/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=0595372b9faf16bdfbe5232f626b66590ae0ba6d0ce183da565817c41e1be6de&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>여기서 알 수 있는 중요한 사실은 catch가 catch 끼리만 체이닝이 되는 것이 아니라, catch 문이 실행되고 나서 resolved된 Promise가 반환되고, 다음 then 체인 블록으로 이동한다는 것이다.</span></p><p><span>→ </span><code><span>The first Error</span></code><span> 를 출력한 첫 번째 catch 블록이 실행되고 나서, 다음 catch 문이 아닌 then 체인 블록으로 이동한 것을 확인할 수 있다.</span></p><p></p><p></p><p></p><h2><span>summary</span></h2><p><span>요약하자면 이렇다.</span></p><li><span>Promise 체이닝 과정에서 에러가 발생하여 Promise 상태가 rejected되면 가장 가까운 catch 체이닝으로 이동한다.</span><ul></ul></li><li><span>catch 내부에서 에러가 발생하여 Promise가 rejected 상태가 되면 다음 catch로 이동한다.</span><ul></ul></li><li><span>이동한 catch에서 반환되는 Promise 객체의 상태에 따라 다음 체이닝으로 이동한다. → resolved(정확히는 </span><em><span>fulfilled</span></em><span> 상태)이면 then, rejected이면 catch</span><ul></ul></li>"}},"pageContext":{"id":"43301004-966a-587a-8a15-4ebdfb37a1cb","title":"[Javascript] .then과 .catch가 여러 개일 때에 대한 케이스 실험","contentHtml":"<p></p><h1><span>Case 1: 비동기와 then, catch</span></h1><p><strong><span>같은 시간의 타이머를 가진 Promise 객체 A가 있다고 가정</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})</span></code></pre><p></p><p></p><p><strong><span>아래와 같이 </span></strong><code><strong><span>then</span></strong></code><strong><span> 과 </span></strong><code><strong><span>catch</span></strong></code><strong><span> 를 chaining을 할 때 결과는?</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">a.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nPromise A rejected!\nYes, it's resolved\nNo, it's rejected</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved</span></code></pre><p></p><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved\nPromise A rejected!</span></code></pre><p></p><p><span>정답은 3번</span></p><p></p><p><span>해설</span></p><li><span>setTimeout은 대표적인 비동기 함수</span><ul></ul></li><li><span>비동기 프로세스와 이벤트 루프에 의해 setTimeout이 처리되는 순서대로 호출된다.</span><ul></ul></li><li><span>위 예시에서는 Promise A를 resolve 처리한 함수가 먼저 호출되었다.</span><ul></ul></li><li><span>Promise A가 resolved 됨에 따라 then이 호출된다.</span><ul></ul></li><li><span>이후에 Promise A를 reject하는 함수가 호출되었으나, Promise A는 이미 상태가 </span><code><span>pending</span></code><span> 상태에서 </span><code><span>fullfilled</span></code><span> 상태가 되었으므로 Promise의 상태가 변경되지 않는다. → 따라서 catch 함수는 실행되지 않는다.</span><ul></ul></li><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/c0f702ff-a014-4f0e-ad20-182338fa1b2b/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=3f6698912732865264f1fc496ecf861429a70672e47133c5a0b1c8de218769dc&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>→ 만약 rejected되는 함수의 타이머 시간을 줄이면 어떻게 될까?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 100)\n})\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>결과는 아래와 같다.</span></p><pre class=\"language-shell\"><code class=\"language-shell\"><span>Promise A rejected!\nNo, it's rejected\nPromise A resolved!</span></code></pre><p></p><p><span>만약 then 함수 안에서 a를 console.log로 찍어보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n  console.log('printed a: ', a) // a 출력\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>fullfilled된 상태의 a가 출력된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/edaca4d6-2384-472b-a167-66bb70967434/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=eda42af2be14b4dd7d344fe7080c6f36e9aed45c87e8cc71ae97991615b7e6b3&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>resolved된 Promise A 객체를 </span><code><span>reject()</span></code><span> 호출 후에 확인해보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n    console.log('printed a: ', a) // a 출력\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p><span>역시나 </span><code><span>fullfilled</span></code><span> 상태의 Promise가 출력된다. 즉 이미 상태가 결정된 Promise는 다른 상태로 변경되지 않는다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7db5d987-e279-471d-9054-d17a32d53c70/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=208cd78e9cc6ccceb48d6f7696e058b91af114709f97ea7d107f198fe30d3468&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><h1><span>Case2: then chain의 error catch 도달 범위</span></h1><p><span>실습 환경: javascript playground</span></p><p><a href=\"https://playcode.io/javascript\">https://playcode.io/javascript</a></p><p><a href=\"https://www.jsplayground.dev/\">https://www.jsplayground.dev/</a></p><p></p><p><span>아래와 같은 Promise 객체가 있고, 여러 개의 </span><code><span>then</span></code><span>  chain이 있다고 가정</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n  .catch(e = console.error(e))\n})\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>그리고 두번째 then chain 부분에 catch chain을 추가</span></p><p></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e)) // catch 문 추가!\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n</span></code></pre><p><span>과연 어떤 에러 문구가 출력이 될까?</span></p><p></p><p><span>정답</span></p><p></p><p><span>그리고 다시 catch 문을 추가해보자. 기존 catch문 바로 아래에 추가</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e))\n.catch(e = console.error(e)) // 두번째 catch 블록\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 </span><code><span>The second Error!</span></code><span> 가 출력이 될까? </span></p><p><span>→ 안된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/125f52e8-2725-4777-aa71-f5ef412e67be/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=d137e69cd043b68ca5cef5e387c6775bf4d4528e5f108bed84e1d6c17ba8cafd&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>원인) 이미 상태가 결정된 Promise는 다른 상태로 전이되지 않는다는 특성 때문</span></p><p><span>따라서 첫번재 then에서 발생한 에러에 의해 then이 반환한 Promise는 rejected 상태가 되고, 체이닝에서 가장 첫번째 catch 블록으로 이동하여 콜백이 실행된다. 해당 catch 블록에서는 더이상 다른 Promise를 반환하지 않으므로 두번째 .then으로 Promise가 실행되지 않는다.</span></p><p></p><p><span>그렇다면 catch 블록 안에서 또 에러를 발생시켜보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error('Here is the first catch block')\n  throw new Error(`Passed Error: ${e} from the first catch block`) // nested Error throwing!\n})\n.catch(e = console.error(e))\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 에러 문구가 출력되는 것을 확인할 수 있다.</span></p><p></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/aef4f0d9-9372-4f89-97cf-5ea6ee40e841/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=8dcc519c91cbee855b485b7c7f867cf248686fd4f2b65456b92bce7b0e659852&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>이번에는 두번째 catch 블록을 지우고 catch 블록에서 resolve 상태의 Promise를 리턴해보자. 그리고 catch 문에는 then 체인이 걸려있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.resolve() // resolved 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})</span></code></pre><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/df0b0551-19e1-42a8-8d5b-2d23f69f5ddd/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=188a015850ca284fc3f5a9015f5e7693edc279cfddfc7f8cc49473d95e3a0b57&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>세번째 then 체인이 실행되는 것을 확인할 수 있다.</span></p><p><span>rejected 상태의 Promise는 어떨까? 해당 Promise 객체를 반환하는 다음 체이닝에 catch 블록이 있다고 가정해본다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') // rejected 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e) // 에러 문구 출력\n})\n</span></code></pre><p></p><p><span>rejected Promise의 에러 문구 내용이 마지막 catch 블록에서 실행되는 것을 확인할 수 있다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/30371ba4-15ab-415d-a91f-25d28b1354e9/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=b8fdf741cd7a0577cea03ae5265cc5766143e8d7f1a002e8a6678c6400fe5110&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><p><span>이제 여러 개의 catch 블록과 여러 개의 then 순서를 뒤바꾸면 코드가 매우 흥미로워진다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.catch(e = console.error(e))\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') \n})\n.then(() = {\n  console.log('This is the second then block')\n  throw new Error('The second Error!')\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e)\n})\n</span></code></pre><p><span>실행 결과는 어떻게 될까?</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7ca64e89-baac-499d-a49b-0216fcb4776f/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T130201Z&X-Amz-Expires=3600&X-Amz-Signature=0595372b9faf16bdfbe5232f626b66590ae0ba6d0ce183da565817c41e1be6de&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>여기서 알 수 있는 중요한 사실은 catch가 catch 끼리만 체이닝이 되는 것이 아니라, catch 문이 실행되고 나서 resolved된 Promise가 반환되고, 다음 then 체인 블록으로 이동한다는 것이다.</span></p><p><span>→ </span><code><span>The first Error</span></code><span> 를 출력한 첫 번째 catch 블록이 실행되고 나서, 다음 catch 문이 아닌 then 체인 블록으로 이동한 것을 확인할 수 있다.</span></p><p></p><p></p><p></p><h2><span>summary</span></h2><p><span>요약하자면 이렇다.</span></p><li><span>Promise 체이닝 과정에서 에러가 발생하여 Promise 상태가 rejected되면 가장 가까운 catch 체이닝으로 이동한다.</span><ul></ul></li><li><span>catch 내부에서 에러가 발생하여 Promise가 rejected 상태가 되면 다음 catch로 이동한다.</span><ul></ul></li><li><span>이동한 catch에서 반환되는 Promise 객체의 상태에 따라 다음 체이닝으로 이동한다. → resolved(정확히는 </span><em><span>fulfilled</span></em><span> 상태)이면 then, rejected이면 catch</span><ul></ul></li>"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}