{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/43301004-966a-587a-8a15-4ebdfb37a1cb/","result":{"data":{"site":{"siteMetadata":{"title":"KSoonYo Blog"}},"notionPage":{"title":"[Javascript] .then과 .catch가 여러 개일 때에 대한 케이스 실험","contentHtml":"<p></p><h1><span>Case 1: 비동기와 then, catch</span></h1><p><strong><span>같은 시간의 타이머를 가진 Promise 객체 A가 있다고 가정</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})</span></code></pre><p></p><p></p><p><strong><span>아래와 같이 </span></strong><code><strong><span>then</span></strong></code><strong><span> 과 </span></strong><code><strong><span>catch</span></strong></code><strong><span> 를 chaining을 할 때 결과는?</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">a.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nPromise A rejected!\nYes, it's resolved\nNo, it's rejected</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved</span></code></pre><p></p><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved\nPromise A rejected!</span></code></pre><p></p><p><span>정답은 3번</span></p><p></p><p><span>해설</span></p><li><span>setTimeout은 대표적인 비동기 함수</span><ul></ul></li><li><span>비동기 프로세스와 이벤트 루프에 의해 setTimeout이 처리되는 순서대로 호출된다.</span><ul></ul></li><li><span>위 예시에서는 Promise A를 resolve 처리한 함수가 먼저 호출되었다.</span><ul></ul></li><li><span>Promise A가 resolved 됨에 따라 then이 호출된다.</span><ul></ul></li><li><span>이후에 Promise A를 reject하는 함수가 호출되었으나, Promise A는 이미 상태가 </span><code><span>pending</span></code><span> 상태에서 </span><code><span>fullfilled</span></code><span> 상태가 되었으므로 Promise의 상태가 변경되지 않는다. → 따라서 catch 함수는 실행되지 않는다.</span><ul></ul></li><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/c0f702ff-a014-4f0e-ad20-182338fa1b2b/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=494f8229b7e4bc97d39d92d6530b7f0b14387dcbfafe703545b39f07dbb80da8&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>→ 만약 rejected되는 함수의 타이머 시간을 줄이면 어떻게 될까?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 100)\n})\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>결과는 아래와 같다.</span></p><pre class=\"language-shell\"><code class=\"language-shell\"><span>Promise A rejected!\nNo, it's rejected\nPromise A resolved!</span></code></pre><p></p><p><span>만약 then 함수 안에서 a를 console.log로 찍어보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n  console.log('printed a: ', a) // a 출력\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>fullfilled된 상태의 a가 출력된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/edaca4d6-2384-472b-a167-66bb70967434/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=7c03bd71f990427b94deecbdd1c59c6a2c5cb3ef1f01e7f867f7bfeddc6a2710&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>resolved된 Promise A 객체를 </span><code><span>reject()</span></code><span> 호출 후에 확인해보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n    console.log('printed a: ', a) // a 출력\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p><span>역시나 </span><code><span>fullfilled</span></code><span> 상태의 Promise가 출력된다. 즉 이미 상태가 결정된 Promise는 다른 상태로 변경되지 않는다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7db5d987-e279-471d-9054-d17a32d53c70/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=0623179c205a3eebdc385abd7ed5fab7216b9d15ef11978748c5cf974d79c73d&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><h1><span>Case2: then chain의 error catch 도달 범위</span></h1><p><span>실습 환경: javascript playground</span></p><p><a href=\"https://playcode.io/javascript\"><span>https://playcode.io/javascript</span></a></p><p><a href=\"https://www.jsplayground.dev/\"><span>https://www.jsplayground.dev/</span></a></p><p></p><p><span>아래와 같은 Promise 객체가 있고, 여러 개의 </span><code><span>then</span></code><span>  chain이 있다고 가정</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n  .catch(e = console.error(e))\n})\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>그리고 두번째 then chain 부분에 catch chain을 추가</span></p><p></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e)) // catch 문 추가!\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n</span></code></pre><p><span>과연 어떤 에러 문구가 출력이 될까?</span></p><p></p><p><span>정답</span></p><p></p><p><span>그리고 다시 catch 문을 추가해보자. 기존 catch문 바로 아래에 추가</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e))\n.catch(e = console.error(e)) // 두번째 catch 블록\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 </span><code><span>The second Error!</span></code><span> 가 출력이 될까? </span></p><p><span>→ 안된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/125f52e8-2725-4777-aa71-f5ef412e67be/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=a13807adbede5d36ec3a67efcd70777e20b63a9aa40240d02b0ab29e9f680b37&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>원인) 이미 상태가 결정된 Promise는 다른 상태로 전이되지 않는다는 특성 때문</span></p><p><span>따라서 첫번재 then에서 발생한 에러에 의해 then이 반환한 Promise는 rejected 상태가 되고, 체이닝에서 가장 첫번째 catch 블록으로 이동하여 콜백이 실행된다. 해당 catch 블록에서는 더이상 다른 Promise를 반환하지 않으므로 두번째 .then으로 Promise가 실행되지 않는다.</span></p><p></p><p><span>그렇다면 catch 블록 안에서 또 에러를 발생시켜보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error('Here is the first catch block')\n  throw new Error(`Passed Error: ${e} from the first catch block`) // nested Error throwing!\n})\n.catch(e = console.error(e))\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 에러 문구가 출력되는 것을 확인할 수 있다.</span></p><p></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/aef4f0d9-9372-4f89-97cf-5ea6ee40e841/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=1e19969bc169000b2e879880081f6642a4fcfd824e099cf24e4e0912a8e90112&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>이번에는 두번째 catch 블록을 지우고 catch 블록에서 resolve 상태의 Promise를 리턴해보자. 그리고 catch 문에는 then 체인이 걸려있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.resolve() // resolved 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})</span></code></pre><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/df0b0551-19e1-42a8-8d5b-2d23f69f5ddd/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=451ce9c85b8dc295a96719772b1ca4caad68267c497ff599229b462351a45f29&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>세번째 then 체인이 실행되는 것을 확인할 수 있다.</span></p><p><span>rejected 상태의 Promise는 어떨까? 해당 Promise 객체를 반환하는 다음 체이닝에 catch 블록이 있다고 가정해본다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') // rejected 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e) // 에러 문구 출력\n})\n</span></code></pre><p></p><p><span>rejected Promise의 에러 문구 내용이 마지막 catch 블록에서 실행되는 것을 확인할 수 있다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/30371ba4-15ab-415d-a91f-25d28b1354e9/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=a69e0498210c1a679afec82b6da6d1dd8e2bccda80b7d86a5910475270e6bfee&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><p><span>이제 여러 개의 catch 블록과 여러 개의 then 순서를 뒤바꾸면 코드가 매우 흥미로워진다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.catch(e = console.error(e))\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') \n})\n.then(() = {\n  console.log('This is the second then block')\n  throw new Error('The second Error!')\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e)\n})\n</span></code></pre><p><span>실행 결과는 어떻게 될까?</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7ca64e89-baac-499d-a49b-0216fcb4776f/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=44323aed85da11a8d788aa62472be3f625bc7529352153380446334abdfb2f30&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>여기서 알 수 있는 중요한 사실은 catch가 catch 끼리만 체이닝이 되는 것이 아니라, catch 문이 실행되고 나서 resolved된 Promise가 반환되고, 다음 then 체인 블록으로 이동한다는 것이다.</span></p><p><span>→ </span><code><span>The first Error</span></code><span> 를 출력한 첫 번째 catch 블록이 실행되고 나서, 다음 catch 문이 아닌 then 체인 블록으로 이동한 것을 확인할 수 있다.</span></p><p></p><p></p><p></p><h2><span>summary</span></h2><p><span>요약하자면 이렇다.</span></p><li><span>Promise 체이닝 과정에서 에러가 발생하여 Promise 상태가 rejected되면 가장 가까운 catch 체이닝으로 이동한다.</span><ul></ul></li><li><span>catch 내부에서 에러가 발생하여 Promise가 rejected 상태가 되면 다음 catch로 이동한다.</span><ul></ul></li><li><span>이동한 catch에서 반환되는 Promise 객체의 상태에 따라 다음 체이닝으로 이동한다. → resolved(정확히는 </span><em><span>fulfilled</span></em><span> 상태)이면 then, rejected이면 catch</span><ul></ul></li><p></p><p><span>Promise의 상태 전이는 아래 MDN 문서의 이미지를 참고할 수 있다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/9f966ff1-20fb-4435-b344-5a2a976c8147/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=913002e70d91da1001b9bff4add3fbeb381d7e1f5199653426d1f2ea5c300acf&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>이는 분명 프로그래밍 언어 관점에서 직관적인 동작 방식으로 보인다. 개인적으로는 일반적인 프로그래밍 언어의 </span><code><span>try-catch</span></code><span> 문의 동작과 </span><code><span>goto</span></code><span> 문이 떠오르는 대목</span></p><p></p><p><span> 하지만 체이닝이 길어지고 순서가 뒤바뀌면 코드의 실행 순서를 파악하기 어렵다는 것이 Promise 체이닝의 단점이며, 이는 </span><code><span>async/await</span></code><span> 문법이 추가된 배경으로 생각할 수 있다.</span></p><p></p><p><strong><span>따라서 만약 Promise 체이닝이 길어지는 상황이라면 </span></strong><code><strong><span>async/await</span></strong></code><strong><span> 문법으로 변환하거나, 코드 상으로 명확하게 실행 순서를 확인할 수 있도록 then과 catch 영역을 구분하여 체이닝을 하는 것이 Best Practice로 보여진다.</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\npromiseA\n// then zone\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  console.log('This is the second then block')\n  throw new Error('The second Error!')\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n// catch zone\n.catch(e = console.error(e))\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') \n})\n.catch(e = {\n  console.error(e)\n})\n</span></code></pre><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/d383fa38-7453-46fe-94c2-0d5c53332bf2/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=7b3075bbdb8c75e9736f4cbb51e476c3299536763938d99316432ca188e89bab&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>하지만 실전에서는 catch zone에서 여러 catch 체이닝을 쓰기보다는 체이닝 과정에서 에러가 발생하면  Error 케이스를 구분하여 한 개의 catch 체이닝으로 해결하는 경우가 더 일반적인 쓰임새.</span></p><p></p><p><span>이제 위 글에서 확인해야 할 부분이 있다. 현재 글에서는 resolved과 fulfilled를 혼용해서 사용한 부분이 있다.</span></p><h3><strong><span>resolved Promise와 fulfilled Promise는 같은 말인가?</span></strong></h3><p><span>아니다.</span></p><p></p><p><strong><span>fulfilled Promise는 이미 상태가 fulfilled로 결정된 Promise를 말하고, resolved된 promise는 pending 상태에서 어떤 다른 상태로 변경되었음을 의미한다.</span></strong></p><p><strong><span>따라서 Promise가 rejected가 되어도 resolved Promise다.</span></strong></p><p><span>MDN 문서에 아래와 같은 설명이 있다.</span></p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p><blockquote class=\"notion-quote\"><span>The </span><a href=\"https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\"><span>States and fates</span></a><span> document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well.</span></blockquote><p></p><h1><span>Case 3: 중첩 Promise</span></h1><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p><p><span>위 문서 예시 코드로 아래와 같은 코드가 있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">new Promise((resolveOuter) = {\n  resolveOuter(\n    new Promise((resolveInner) = {\n      setTimeout(resolveInner, 1000);\n    }),\n  );\n});</span></code></pre><p></p><h2><span>어떻게 사용할 수 있을까?</span></h2><li><span>순차적으로 비동기 작업을 수행할 때 유용하다.</span><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">function stepOne() {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      console.log(\"Step One Complete\");\n      resolve();\n    }, 1000);\n  });\n}\n\nfunction stepTwo() {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      console.log(\"Step Two Complete\");\n      resolve();\n    }, 1000);\n  });\n}\n\nstepOne().then(() = {\n  return stepTwo();\n}).then(() = {\n  console.log(\"All steps complete\");\n});</span></code></pre><p><span>결과</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7be2121e-048f-48bc-bab6-91e0e3e87402/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=1998f8e9d5b391f8a9d1c808b2a0dcc34c6248cb9c3f26912c5041fa10862daf&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>더 응용한다면, 사용자가 선택한 옵션들에 따라 순차적으로 데이터를 fetch하고 싶을 때에도 사용 가능하다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">function fetchData(option) {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      resolve(`Data for ${option}`);\n    }, 1000);\n  });\n}\n\nfunction processOption(option) {\n  return new Promise((resolve) = {\n    fetchData(option).then((data) = {\n      console.log(data);\n      resolve();\n    });\n  });\n}\n\nprocessOption(\"Option 1\").then(() = {\n  return processOption(\"Option 2\");\n}).then(() = {\n  console.log(\"All options processed\");\n});\n</span></code></pre><p></p><p><span>결과</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/d7467f38-c295-493a-bfed-489fd78799fc/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=0e036f9df5e7f1e053e4dca2804e4cf32482ce5c1ea642f43abaac8398ceccc9&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>하지만 위와 같이 작성한다면 fetch 로직이 조금만 더 길어질 때 가독성에 악영향을 줄 것이다.</span></p><p><span>이럴 때에는 </span><code><span>async/await</span></code><span>를 사용하는 것이 더 효과적일 수 있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">function fetchData(option) {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      resolve(`Data for ${option}`);\n    }, 1000);\n  });\n}\n\nasync function processOption(option) {\n  const data = await fetchData(option);\n  console.log(data);\n}\n\nasync function runOptions() {\n  await processOption(\"Option 1\");\n  await processOption(\"Option 2\");\n  console.log(\"All options processed\");\n}\n\nrunOptions();</span></code></pre><p></p><h1><span>참고</span></h1><p><a href=\"https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\">link:https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md</a></p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p><p></p>"}},"pageContext":{"id":"43301004-966a-587a-8a15-4ebdfb37a1cb","title":"[Javascript] .then과 .catch가 여러 개일 때에 대한 케이스 실험","contentHtml":"<p></p><h1><span>Case 1: 비동기와 then, catch</span></h1><p><strong><span>같은 시간의 타이머를 가진 Promise 객체 A가 있다고 가정</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})</span></code></pre><p></p><p></p><p><strong><span>아래와 같이 </span></strong><code><strong><span>then</span></strong></code><strong><span> 과 </span></strong><code><strong><span>catch</span></strong></code><strong><span> 를 chaining을 할 때 결과는?</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">a.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nPromise A rejected!\nYes, it's resolved\nNo, it's rejected</span></code></pre><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved</span></code></pre><p></p><p></p><pre class=\"language-bash\"><code class=\"language-bash\"><span>Promise A resolved!\nYes, it's resolved\nPromise A rejected!</span></code></pre><p></p><p><span>정답은 3번</span></p><p></p><p><span>해설</span></p><li><span>setTimeout은 대표적인 비동기 함수</span><ul></ul></li><li><span>비동기 프로세스와 이벤트 루프에 의해 setTimeout이 처리되는 순서대로 호출된다.</span><ul></ul></li><li><span>위 예시에서는 Promise A를 resolve 처리한 함수가 먼저 호출되었다.</span><ul></ul></li><li><span>Promise A가 resolved 됨에 따라 then이 호출된다.</span><ul></ul></li><li><span>이후에 Promise A를 reject하는 함수가 호출되었으나, Promise A는 이미 상태가 </span><code><span>pending</span></code><span> 상태에서 </span><code><span>fullfilled</span></code><span> 상태가 되었으므로 Promise의 상태가 변경되지 않는다. → 따라서 catch 함수는 실행되지 않는다.</span><ul></ul></li><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/c0f702ff-a014-4f0e-ad20-182338fa1b2b/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=494f8229b7e4bc97d39d92d6530b7f0b14387dcbfafe703545b39f07dbb80da8&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>→ 만약 rejected되는 함수의 타이머 시간을 줄이면 어떻게 될까?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 100)\n})\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>결과는 아래와 같다.</span></p><pre class=\"language-shell\"><code class=\"language-shell\"><span>Promise A rejected!\nNo, it's rejected\nPromise A resolved!</span></code></pre><p></p><p><span>만약 then 함수 안에서 a를 console.log로 찍어보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n  console.log('printed a: ', a) // a 출력\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p></p><p><span>fullfilled된 상태의 a가 출력된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/edaca4d6-2384-472b-a167-66bb70967434/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=7c03bd71f990427b94deecbdd1c59c6a2c5cb3ef1f01e7f867f7bfeddc6a2710&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>resolved된 Promise A 객체를 </span><code><span>reject()</span></code><span> 호출 후에 확인해보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const a = new Promise((resolve, reject)= {\n  setTimeout(() = {\n    console.log('Promise A resolved!')\n    resolve()\n  },300)\n\n  setTimeout(() = {\n    console.log('Promise A rejected!')\n    reject()\n    console.log('printed a: ', a) // a 출력\n  }, 300)\n})\n\n\na.then(() = {\n  console.log('Yes, it\\'s resolved')\n}).catch(() = {\n  console.log('No, it\\'s rejected')\n})\n</span></code></pre><p><span>역시나 </span><code><span>fullfilled</span></code><span> 상태의 Promise가 출력된다. 즉 이미 상태가 결정된 Promise는 다른 상태로 변경되지 않는다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7db5d987-e279-471d-9054-d17a32d53c70/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=0623179c205a3eebdc385abd7ed5fab7216b9d15ef11978748c5cf974d79c73d&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><h1><span>Case2: then chain의 error catch 도달 범위</span></h1><p><span>실습 환경: javascript playground</span></p><p><a href=\"https://playcode.io/javascript\"><span>https://playcode.io/javascript</span></a></p><p><a href=\"https://www.jsplayground.dev/\"><span>https://www.jsplayground.dev/</span></a></p><p></p><p><span>아래와 같은 Promise 객체가 있고, 여러 개의 </span><code><span>then</span></code><span>  chain이 있다고 가정</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n  .catch(e = console.error(e))\n})\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>그리고 두번째 then chain 부분에 catch chain을 추가</span></p><p></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e)) // catch 문 추가!\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n</span></code></pre><p><span>과연 어떤 에러 문구가 출력이 될까?</span></p><p></p><p><span>정답</span></p><p></p><p><span>그리고 다시 catch 문을 추가해보자. 기존 catch문 바로 아래에 추가</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)\n})\n\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = console.error(e))\n.catch(e = console.error(e)) // 두번째 catch 블록\n.then(() = {\n  throw new Error('The third Error!')\n})\n\n\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 </span><code><span>The second Error!</span></code><span> 가 출력이 될까? </span></p><p><span>→ 안된다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/125f52e8-2725-4777-aa71-f5ef412e67be/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=a13807adbede5d36ec3a67efcd70777e20b63a9aa40240d02b0ab29e9f680b37&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>원인) 이미 상태가 결정된 Promise는 다른 상태로 전이되지 않는다는 특성 때문</span></p><p><span>따라서 첫번재 then에서 발생한 에러에 의해 then이 반환한 Promise는 rejected 상태가 되고, 체이닝에서 가장 첫번째 catch 블록으로 이동하여 콜백이 실행된다. 해당 catch 블록에서는 더이상 다른 Promise를 반환하지 않으므로 두번째 .then으로 Promise가 실행되지 않는다.</span></p><p></p><p><span>그렇다면 catch 블록 안에서 또 에러를 발생시켜보면?</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error('Here is the first catch block')\n  throw new Error(`Passed Error: ${e} from the first catch block`) // nested Error throwing!\n})\n.catch(e = console.error(e))\n.then(() = {\n  throw new Error('The third Error!')\n})\n</span></code></pre><p><span>이번에는 두번째 catch 블록에서 에러 문구가 출력되는 것을 확인할 수 있다.</span></p><p></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/aef4f0d9-9372-4f89-97cf-5ea6ee40e841/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=1e19969bc169000b2e879880081f6642a4fcfd824e099cf24e4e0912a8e90112&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>이번에는 두번째 catch 블록을 지우고 catch 블록에서 resolve 상태의 Promise를 리턴해보자. 그리고 catch 문에는 then 체인이 걸려있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.resolve() // resolved 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})</span></code></pre><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/df0b0551-19e1-42a8-8d5b-2d23f69f5ddd/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=451ce9c85b8dc295a96719772b1ca4caad68267c497ff599229b462351a45f29&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>세번째 then 체인이 실행되는 것을 확인할 수 있다.</span></p><p><span>rejected 상태의 Promise는 어떨까? 해당 Promise 객체를 반환하는 다음 체이닝에 catch 블록이 있다고 가정해본다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\npromiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  throw new Error('The second Error!')\n})\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') // rejected 된 Promise 객체 반환\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e) // 에러 문구 출력\n})\n</span></code></pre><p></p><p><span>rejected Promise의 에러 문구 내용이 마지막 catch 블록에서 실행되는 것을 확인할 수 있다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/30371ba4-15ab-415d-a91f-25d28b1354e9/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=a69e0498210c1a679afec82b6da6d1dd8e2bccda80b7d86a5910475270e6bfee&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p></p><p><span>이제 여러 개의 catch 블록과 여러 개의 then 순서를 뒤바꾸면 코드가 매우 흥미로워진다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">promiseA\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.catch(e = console.error(e))\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') \n})\n.then(() = {\n  console.log('This is the second then block')\n  throw new Error('The second Error!')\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n.catch(e = {\n  console.error(e)\n})\n</span></code></pre><p><span>실행 결과는 어떻게 될까?</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7ca64e89-baac-499d-a49b-0216fcb4776f/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=44323aed85da11a8d788aa62472be3f625bc7529352153380446334abdfb2f30&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>여기서 알 수 있는 중요한 사실은 catch가 catch 끼리만 체이닝이 되는 것이 아니라, catch 문이 실행되고 나서 resolved된 Promise가 반환되고, 다음 then 체인 블록으로 이동한다는 것이다.</span></p><p><span>→ </span><code><span>The first Error</span></code><span> 를 출력한 첫 번째 catch 블록이 실행되고 나서, 다음 catch 문이 아닌 then 체인 블록으로 이동한 것을 확인할 수 있다.</span></p><p></p><p></p><p></p><h2><span>summary</span></h2><p><span>요약하자면 이렇다.</span></p><li><span>Promise 체이닝 과정에서 에러가 발생하여 Promise 상태가 rejected되면 가장 가까운 catch 체이닝으로 이동한다.</span><ul></ul></li><li><span>catch 내부에서 에러가 발생하여 Promise가 rejected 상태가 되면 다음 catch로 이동한다.</span><ul></ul></li><li><span>이동한 catch에서 반환되는 Promise 객체의 상태에 따라 다음 체이닝으로 이동한다. → resolved(정확히는 </span><em><span>fulfilled</span></em><span> 상태)이면 then, rejected이면 catch</span><ul></ul></li><p></p><p><span>Promise의 상태 전이는 아래 MDN 문서의 이미지를 참고할 수 있다.</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/9f966ff1-20fb-4435-b344-5a2a976c8147/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=913002e70d91da1001b9bff4add3fbeb381d7e1f5199653426d1f2ea5c300acf&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>이는 분명 프로그래밍 언어 관점에서 직관적인 동작 방식으로 보인다. 개인적으로는 일반적인 프로그래밍 언어의 </span><code><span>try-catch</span></code><span> 문의 동작과 </span><code><span>goto</span></code><span> 문이 떠오르는 대목</span></p><p></p><p><span> 하지만 체이닝이 길어지고 순서가 뒤바뀌면 코드의 실행 순서를 파악하기 어렵다는 것이 Promise 체이닝의 단점이며, 이는 </span><code><span>async/await</span></code><span> 문법이 추가된 배경으로 생각할 수 있다.</span></p><p></p><p><strong><span>따라서 만약 Promise 체이닝이 길어지는 상황이라면 </span></strong><code><strong><span>async/await</span></strong></code><strong><span> 문법으로 변환하거나, 코드 상으로 명확하게 실행 순서를 확인할 수 있도록 then과 catch 영역을 구분하여 체이닝을 하는 것이 Best Practice로 보여진다.</span></strong></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">const promiseA = new Promise((resolve, reject) = {\n  setTimeout(() = {\n    console.log('Promise resolving . . .')\n    resolve('123')\n  }, 300)})\n\n\npromiseA\n// then zone\n.then((data) = {\n  console.log('resolved Data: ', data)\n  throw new Error('The first Error')\n})\n.then(() = {\n  console.log('This is the second then block')\n  throw new Error('The second Error!')\n})\n.then(() = {\n  console.log('This is the thrid then block')\n  throw new Error('The third Error!')\n})\n// catch zone\n.catch(e = console.error(e))\n.catch(e = {\n  console.error(e)\n  return Promise.reject('rejected Promise') \n})\n.catch(e = {\n  console.error(e)\n})\n</span></code></pre><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/d383fa38-7453-46fe-94c2-0d5c53332bf2/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=7b3075bbdb8c75e9736f4cbb51e476c3299536763938d99316432ca188e89bab&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p><span>하지만 실전에서는 catch zone에서 여러 catch 체이닝을 쓰기보다는 체이닝 과정에서 에러가 발생하면  Error 케이스를 구분하여 한 개의 catch 체이닝으로 해결하는 경우가 더 일반적인 쓰임새.</span></p><p></p><p><span>이제 위 글에서 확인해야 할 부분이 있다. 현재 글에서는 resolved과 fulfilled를 혼용해서 사용한 부분이 있다.</span></p><h3><strong><span>resolved Promise와 fulfilled Promise는 같은 말인가?</span></strong></h3><p><span>아니다.</span></p><p></p><p><strong><span>fulfilled Promise는 이미 상태가 fulfilled로 결정된 Promise를 말하고, resolved된 promise는 pending 상태에서 어떤 다른 상태로 변경되었음을 의미한다.</span></strong></p><p><strong><span>따라서 Promise가 rejected가 되어도 resolved Promise다.</span></strong></p><p><span>MDN 문서에 아래와 같은 설명이 있다.</span></p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p><blockquote class=\"notion-quote\"><span>The </span><a href=\"https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\"><span>States and fates</span></a><span> document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well.</span></blockquote><p></p><h1><span>Case 3: 중첩 Promise</span></h1><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p><p><span>위 문서 예시 코드로 아래와 같은 코드가 있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">new Promise((resolveOuter) = {\n  resolveOuter(\n    new Promise((resolveInner) = {\n      setTimeout(resolveInner, 1000);\n    }),\n  );\n});</span></code></pre><p></p><h2><span>어떻게 사용할 수 있을까?</span></h2><li><span>순차적으로 비동기 작업을 수행할 때 유용하다.</span><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">function stepOne() {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      console.log(\"Step One Complete\");\n      resolve();\n    }, 1000);\n  });\n}\n\nfunction stepTwo() {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      console.log(\"Step Two Complete\");\n      resolve();\n    }, 1000);\n  });\n}\n\nstepOne().then(() = {\n  return stepTwo();\n}).then(() = {\n  console.log(\"All steps complete\");\n});</span></code></pre><p><span>결과</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/7be2121e-048f-48bc-bab6-91e0e3e87402/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=1998f8e9d5b391f8a9d1c808b2a0dcc34c6248cb9c3f26912c5041fa10862daf&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>더 응용한다면, 사용자가 선택한 옵션들에 따라 순차적으로 데이터를 fetch하고 싶을 때에도 사용 가능하다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">function fetchData(option) {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      resolve(`Data for ${option}`);\n    }, 1000);\n  });\n}\n\nfunction processOption(option) {\n  return new Promise((resolve) = {\n    fetchData(option).then((data) = {\n      console.log(data);\n      resolve();\n    });\n  });\n}\n\nprocessOption(\"Option 1\").then(() = {\n  return processOption(\"Option 2\");\n}).then(() = {\n  console.log(\"All options processed\");\n});\n</span></code></pre><p></p><p><span>결과</span></p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/673168e8-0d7f-4b4b-b2ff-30cbb7c5b0cc/d7467f38-c295-493a-bfed-489fd78799fc/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20241125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241125T152011Z&X-Amz-Expires=3600&X-Amz-Signature=0e036f9df5e7f1e053e4dca2804e4cf32482ce5c1ea642f43abaac8398ceccc9&X-Amz-SignedHeaders=host&x-id=GetObject\" alt=\"undefined\" /><p></p><p><span>하지만 위와 같이 작성한다면 fetch 로직이 조금만 더 길어질 때 가독성에 악영향을 줄 것이다.</span></p><p><span>이럴 때에는 </span><code><span>async/await</span></code><span>를 사용하는 것이 더 효과적일 수 있다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span data-right-bracket=\"true\">function fetchData(option) {\n  return new Promise((resolve) = {\n    setTimeout(() = {\n      resolve(`Data for ${option}`);\n    }, 1000);\n  });\n}\n\nasync function processOption(option) {\n  const data = await fetchData(option);\n  console.log(data);\n}\n\nasync function runOptions() {\n  await processOption(\"Option 1\");\n  await processOption(\"Option 2\");\n  console.log(\"All options processed\");\n}\n\nrunOptions();</span></code></pre><p></p><h1><span>참고</span></h1><p><a href=\"https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\">link:https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md</a></p><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></p><p></p>"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}