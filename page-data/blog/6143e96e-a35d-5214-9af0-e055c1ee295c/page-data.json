{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/6143e96e-a35d-5214-9af0-e055c1ee295c/","result":{"data":{"site":{"siteMetadata":{"title":"KSoonYo Blog"}},"notionPage":{"title":"[React] 끈적거리는 다이얼로그 선언적으로 관리하기","contentHtml":"<ul><li><span>본 글은 모달과 다이얼로그의 개념을 엄밀하게 구분하지 않고 혼용해서 사용하고 있으니 참고해주세요. 팝업 UI를 모두 다이얼로그로 지칭하고 있습니다.</span></li></ul><h1><span>배경</span></h1><p><span>전 회사에서 근무했을 때, 아래와 같은 코드를 발견했다. 다른 로직들은 다 제거하고 다이얼로그와 관련된 코드 예시다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">\nimport { useState } from 'react';\n\nimport AlertDialog from '@component/dialog';\n\nconst Component = () = {\n   const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    div\n      button onClick={() = {setIsOpen(true)}} 버튼 /button\n      {isOpen && AlertDialog / }\n    /div\n\n  )\n\n}\n</span></code></pre><p><span>위 코드에서 </span><strong><span>AlertDialog</span></strong><span>는 웹페이지에서 어떤 버튼을 클릭했을 때, 사용자에게 정보를 알려주는 다이얼로그다. 대충 아래의 다이얼로그와 비슷한 경우라고 할 수 있다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/8abdbeda-2d08-4d06-9d17-94e0da9d83dc/image.png\" alt=\"undefined\" /><p><span>간단한 다이얼로그를 사용하는 경우라면 크게 상관 없을 지도 모른다. 하지만 세상 일이라는 것이 단순하면서도 단순하지 않다.</span></p><h1><span>문제 상황: 끈적거리는 다이얼로그</span></h1><p><span>위의 예시처럼 정해진 정보를 사용자에게 알려주고, 확인 버튼을 누르면 닫는 방식의 다이얼로그는 외부에서 전달 받는 데이터가 없다.</span></p><p><span>하지만 아래와 같이 다이얼로그에 따라 다이얼로그 외부의 데이터를 전달받아야 하는 상황이 발생할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import React from 'react';\n\ntype UserData = {\n  name: string;\n  age: number;\n  address: string;\n};\n\ntype MyComplexDialogProps = {\n  isOpen: boolean;\n  user: UserData;\n  errorMessages: string[];\n  currentStep: number;\n  isVerified: boolean;\n  isLoading: boolean;\n  onConfirm: () = void;\n  onCancel: () = void;\n  onRetry: () = void;\n};\n\nfunction MyComplexDialog({\n  isOpen,\n  user,\n  errorMessages,\n  currentStep,\n  isVerified,\n  isLoading,\n  onConfirm,\n  onCancel,\n  onRetry,\n}: MyComplexDialogProps) {\n  if (!isOpen) return null;\n\n  return (\n    div\n      style={{\n        border: '1px solid #ccc',\n        padding: '16px',\n        backgroundColor: '#fff',\n      }}\n    \n      h2복잡한 다이얼로그/h2\n      p현재 스텝: {currentStep}/p\n      p사용자 이름: {user.name}/p\n      p나이: {user.age}/p\n      p주소: {user.address}/p\n      p인증 여부: {isVerified ? '인증됨' : '인증 안됨'}/p\n\n      {errorMessages.length  0 && (\n        div style={{ color: 'red' }}\n          h3에러 메시지/h3\n          ul\n            {errorMessages.map((msg, idx) = (\n              li key={idx}{msg}/li\n            ))}\n          /ul\n        /div\n      )}\n\n      div\n        button onClick={onConfirm} disabled={isLoading}\n          확인\n        /button\n        button onClick={onCancel}취소/button\n        {!isVerified && (\n          button onClick={onRetry} disabled={isLoading}\n            재시도\n          /button\n        )}\n      /div\n    /div\n  );\n}\n\nexport default MyComplexDialog;\n\n</span></code></pre><p><span>다이얼로그를 사용하는 컴포넌트 </span><code><span>ParentComponent</span></code><span> 는 이 다이얼로그를 사용하기 위해 필요한 데이터를 관리하고 트리거하여 전달한다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import React, { useState } from 'react';\nimport MyComplexDialog from './MyComplexDialog'; // 다이얼로그 import\n\nfunction ParentComponent() {\n  // 사용자 관련 상태\n  const [userName, setUserName] = useState('홍길동');\n  const [userAge, setUserAge] = useState(20);\n  const [userAddress, setUserAddress] = useState('서울');\n\n  // 에러 관련 상태\n  const [errorMessages, setErrorMessages] = useStatestring[]([]);\n\n  // 다이얼로그 노출 상태\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n\n  // 인증 상태, 로딩 상태\n  const [isVerified, setIsVerified] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // 단계 관리\n  const [currentStep, setCurrentStep] = useState(1);\n\n  // 다이얼로그 열기\n  const handleOpenDialog = () = {\n    setIsDialogOpen(true);\n  };\n\n  // 다이얼로그 닫기\n  const handleCloseDialog = () = {\n    setIsDialogOpen(false);\n    // 다이얼로그를 닫을 때, 에러 초기화나 단계도 초기화할 수 있음\n    setErrorMessages([]);\n    setCurrentStep(1);\n  };\n\n  // 확인(확정) 버튼\n  const handleConfirm = () = {\n    // 확인 시 로직 예시\n    if (!isVerified) {\n      setErrorMessages((prev) = [...prev, '아직 인증되지 않았습니다.']);\n      return;\n    }\n    alert('확인되었습니다!');\n    handleCloseDialog();\n  };\n\n  // 재시도 버튼\n  const handleRetry = async () = {\n    setIsLoading(true);\n    // 인증 재시도 로직 예시 (가짜 타이머)\n    setTimeout(() = {\n      setIsVerified(true);\n      setIsLoading(false);\n      setCurrentStep((step) = step + 1);\n    }, 1000);\n  };\n\n  return (\n    div\n      h1다이얼로그 사용 예시/h1\n      p이름: {userName}/p\n      p나이: {userAge}/p\n      p주소: {userAddress}/p\n\n      button onClick={handleOpenDialog}복잡한 다이얼로그 열기/button\n\n      MyComplexDialog\n        // 다이얼로그 열림 여부\n        isOpen={isDialogOpen}\n        // 사용자 정보\n        user={{\n          name: userName,\n          age: userAge,\n          address: userAddress,\n        }}\n        // 에러 목록\n        errorMessages={errorMessages}\n        // 현재 단계, 인증 여부, 로딩 상태\n        currentStep={currentStep}\n        isVerified={isVerified}\n        isLoading={isLoading}\n        // 콜백 함수\n        onConfirm={handleConfirm}\n        onCancel={handleCloseDialog}\n        onRetry={handleRetry}\n      /\n    /div\n  );\n}\n\nexport default ParentComponent;\n\n</span></code></pre><p><span>MyComplexDialog 다이얼로그를 트리거하여 state를 props로 전달해야 할 필요는 알겠지만, 이런 방식으로 전달하는 방법은 언뜻 봐도 문제가 있어 보인다.</span></p><p><span>또한 UI 컴포넌트는 필요하다면 API 서버와 통신하여 데이터를 fetch 하는 로직도 필요하다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-right-bracket=\"true\">import { useEffect } from 'react';\n\nfunction ParentComponent() {\n  // 사용자 관련 상태\n  const [userName, setUserName] = useState('홍길동');\n  const [userAge, setUserAge] = useState(20);\n  const [userAddress, setUserAddress] = useState('서울');\n\n  // ... 중략 ...\n\n  // User data fetch\n  useEffect(() ={\n  \tasync function fetchUserData() = {\n    \tconst response = await fetch('url');\n      \tconst data = await response.json();\n\n      \tsetUserName(data.userName);\n      \tsetUserAge(data.userAge);\n      \tsetUserAddress(data.userAddress)\n    }\n    fetchUserData();\n  }, [])\n\n  // ... 중략 ...\n\n}\n</span></code></pre><p><code><span>ParentComponent</span></code><span>에 </span><code><span>MyComplexDialog</span></code><span>와는 관계 없는 state와 effect 로직이 많아질수록, 언제 사용될지 모르는 </span><code><span>MyComplexDialog</span></code><span>가 껌딱지처럼 </span><code><span>ParentComponent</span></code><span> 코드에 달라붙어있는 모습은 유지보수와 확장에 큰 악영향을 준다.</span></p><p><span>만약 둘 중 하나라도 코드를 수정해야 하는 상황이 된다면, 예를 들어 적어도 props 중 전달받는 data의 타입이 달라지는 상황에 처한다면 다이얼로그의 Props 타입을 슬쩍 수정한 것만으로도 파일 목록에 시뻘건 줄이 그어져 있는 모습을 마주할 수 있을 것이다.</span></p><h1><span>문제 해결 목표</span></h1><p><span>다이얼로그를 최대한 덜 끈적거리게 사용하는 방법을 </span><code><span>Context API</span></code><span>와 </span><code><span>Custom Hook</span></code><span>을 통해 구현해보고자 한다.</span></p><p><span>Context API는 컴포넌트 간 상태 공유를 위해 사용하는 것이므로 필요에 맞게 zustand, recoil 같은 클라이언트 상태 관리 라이브러리로 대체하면 구현이 훨씬 간편해질 수 있다.</span></p><p><span>하지만 팀 상황에 따라 React의 기본 인터페이스로만 우선 작업해야 하는 경우가 있으므로, Context API로 구현해본다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import { useEffect } from 'react';\n\nimport { useDialogAction } from './hooks';\nimport { DialogTypes } from './dialog';\n\n\nfunction ParentComponent(){\n  // ... 생략 ...\n  const { openDialog, closeDialog, updateDialog } = useDialogAction();\n\n  // User data fetch\n  useEffect(() ={\n  \tasync function fetchUserData() = {\n    \tconst response = await fetch('url');\n      \tconst data = await response.json();\n\n      \tsetUserName(data.userName);\n      \tsetUserAge(data.userAge);\n      \tsetUserAddress(data.userAddress)\n    }\n\n    fetchUserData();\n  }, [])\n\n  // Dialog 상태 업데이트(option)\n  useEffect(() = {\n    updateDialog(DialogTypes.User, (prev) = ({\n    \t...prev,\n      \tuser: {\n        \tname: userName,\n          \tage: userAge,\n          \taddress: userAddress\n        }\n    }), true);\n  }, [userName, userAge, useAddress])\n\n  return (\n    div\n      h1다이얼로그 사용 예시/h1\n      p이름: {userName}/p\n      p나이: {userAge}/p\n      p주소: {userAddress}/p\n\n      button onClick={() = {\n        openDialog(DialogTypes.User)\n    \t}}\n        복잡한 다이얼로그 열기\n      /button\n    /div\n  );\n\n}\n\n</span></code></pre><h2><span>1단계: Context 정의하기</span></h2><p><span>먼저 다이얼로그 관리를 위한 Context를 정의한다. </span><code><span>createContext</span></code><span>와 </span><code><span>useReducer</span></code><span>를 조합해 사용하며, 여기서는 다이얼로그가 여러 개 동시에 열릴 수 있다는 점을 고려해 다이얼로그 상태를 배열 형태로 관리한다.</span></p><ul><li><code><span>DialogContext</span></code><span>에서는 현재 열려 있는 다이얼로그 배열을 조회하고,</span></li><li><code><span>DialogDispatchContext</span></code><span>에서는 다이얼로그를 열거나 닫는 액션을 수행한다.</span></li></ul><p><span>이렇게 Context를 두 가지로 나누는 이유는, **읽기(dialog 상태 조회)와 쓰기(dispatch로 액션 전달)를 분리하기 위해서다. **</span></p><p><span>아래 예시처럼 </span><code><span>DialogProvider</span></code><span>를 구현하고, 내부에서 reducer를 통해 dialog 상태와 액션을 관리한다. 또한 뒤로 가기(브라우저 히스토리 popstate)가 발생하면 모든 다이얼로그를 닫도록 처리해, 다이얼로그가 브라우저 이동 히스토리에 끼어들지 않도록 한다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// contexts/dialog\n\nimport React, { createContext, Dispatch, useEffect, useReducer } from 'react';\nimport { DialogType, DialogProps } from 'components/common/dialog/types';\n\nexport type Dialog = {\n  type: DialogType;\n  props: DialogProps[DialogType];\n} | null;\n\nexport type DialogActionT extends DialogType =\n  | {\n      type: 'SHOW_DIALOG';\n      dialogType: T;\n      dialogProps: DialogProps[T];\n    }\n  | { type: 'HIDE_DIALOG' }\n  | { type: 'HIDE_DIALOG_ALL' }\n  | {\n      type: 'SHOW_ERROR';\n      dialogProps: DialogProps[T];\n      error?: Error;\n      redirectTo?: string;\n    };\n\ntype DialogContextType = {\n  dialog: Dialog[];\n} | null;\n\nexport const DialogContext = createContextDialogContextType(null);\nexport const DialogDispatchContext = createContext\n  DispatchDialogActionDialogType | undefined\n(undefined);\n\nfunction reducer(dialog: Dialog[], action: DialogActionDialogType): Dialog[] {\n  switch (action.type) {\n    case 'SHOW_DIALOG':\n      return [\n        ...dialog,\n        {\n          type: action.dialogType,\n          props: { ...action.dialogProps, isOpen: true },\n        },\n      ];\n    case 'HIDE_DIALOG':\n      return dialog.slice(0, -1);\n    case 'HIDE_DIALOG_ALL':\n      return [];\n    case 'SHOW_ERROR':\n      return [\n        ...dialog,\n        {\n          type: 'ERROR',\n          props: {\n            ...action.dialogProps,\n            isOpen: true,\n            title: action.error?.title,\n            message: action.error?.message,\n            redirectTo: action.redirectTo,\n          },\n        },\n      ];\n    default:\n      return dialog;\n  }\n}\nexport function DialogProvider({ children }: { children: React.ReactNode }) {\n  const [dialog, dispatch] = useReducer(reducer, []);\n\n  useEffect(() = {\n    const handlePopState = () = {\n      dispatch({ type: 'HIDE_DIALOG_ALL' });\n    };\n\n    window.addEventListener('popstate', handlePopState);\n\n    return () = {\n      window.removeEventListener('popstate', handlePopState);\n    };\n  }, [dispatch]);\n\n  return (\n    DialogContext.Provider value={{ dialog }}\n      DialogDispatchContext.Provider value={dispatch}\n        {children}\n      /DialogDispatchContext.Provider\n    /DialogContext.Provider\n  );\n}\n\n</span></code></pre><h2><span>1.5단계: Dialog와 Dialog Component Props 타입 구조화하기 (선택)</span></h2><p><span>다이얼로그가 많아지면 다이얼로그 별로 필요한 props가 달라 복잡해지기 쉽다. 이 문제는 TypeScript를 사용하면 쉽게 해결할 수 있다.</span></p><p><span>예를 들어 다이얼로그 타입을 미리 정의하고, DialogType별로 필요한 props를 모아두는 전략을 취할 수 있다.</span></p><p><span>DialogTypeMapper 객체를 만들어 다음과 같이 작성해보자.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span>export const DialogTypeMapper = {\n  Confirm: 'CONFIRM',\n  Error: 'ERROR',\n  User: 'USER',\n} as const;\n\nexport type DialogType = (typeof DialogTypeMapper)[keyof typeof DialogTypeMapper];\n</span></code></pre><p><span>이렇게 문자열 리터럴 타입을 만들고, 각 다이얼로그 종류별로 필요한 props를 </span><code><span>DialogProps</span></code><span>라는 매핑 타입에 정리한다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span>export type DialogProps = {\n  CONFIRM: ConfirmDialogProps;\n  ERROR: ErrorDialogProps;\n  USER: UserDialogProps;\n};\n</span></code></pre><p><span>이렇게 정리하면, 다이얼로그가 많아질수록 props 관리가 훨씬 명확해진다. props 구조가 바뀌면, 다이얼로그를 사용하는 쪽에서 타입 에러를 통해 문제를 빠르게 찾을 수 있기 때문이다.</span></p><p><span>만약 새로운 다이얼로그를 생성하고자 한다면 아래와 같이 Props를 지정해줄 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// 코드 예시\n\nimport { useEffect, useState } from 'react';\nimport type { DialogProps } from './types';\n\nexport const ConfirmDialog = ({\n  isOpen = false,\n  onClose,\n  title,\n  message,\n  ok,\n  cancel,\n  hideOk,\n  textInput,\n  width = 360,\n  height,\n  onKeyUp,\n}: DialogProps['CONFIRM']) = {\n  const [text, setText] = useState('');\n\n  return (\n    Dialog\n      open={isOpen}\n      onClose={onClose}\n      onKeyUp={onKeyUp}\n    \n\t\t{...}\n    /Dialog\n  );\n};\n</span></code></pre><h2><span>2단계: Render Dialog Root Component 생성하기</span></h2><p><span>Context에 저장된 다이얼로그 배열을 실제로 렌더링할 컴포넌트를 만드는 방법이다.</span></p><p><span>예를 들어 </span><code><span>DialogRoot</span></code><span>라는 컴포넌트를 만들어, dialog 상태를 순회하면서 알맞은 다이얼로그 컴포넌트를 매핑한다.</span></p><p><span>dialog 배열에는 </span><code><span>{ type, props }</span></code><span> 형태의 객체가 들어 있다.</span></p><p><span>type을 통해 어떤 다이얼로그인지 식별하고,</span></p><p><span>그에 맞는 컴포넌트를 </span><code><span>DIALOG_CONTENT_TYPES</span></code><span> 객체에서 가져와 렌더링한다.</span></p><p><span>이렇게 공통 Root를 두면, 다양한 다이얼로그를 한 곳에서 일괄 관리할 수 있다.</span></p><ul><li><span>*예를들어, ConfirmDialog, AlertDialog, UserDialog 등 여러 다이얼로그를 한꺼번에 매핑해줄 수 있다.\n**</span></li></ul><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import { DialogType } from 'components/common/dialog/types/DialogTypeMapper.ts';\nimport { useDialog } from 'hooks/dialog';\nimport {\n  ConfirmDialog,\n  UserDialog,\n // ...\n} from '../common/dialog';\n\nconst DIALOG_CONTENT_TYPES: { [key in DialogType]: any } = {\n  USER: UserDialog,\n  CONFIRM: ConfirmDialog,\n};\n\nconst DialogRoot = () = {\n  const context = useDialog();\n  const { dialog } = context;\n\n  if (!dialog) return /;\n\n  return (\n    \n      {dialog.map((info, idx) = {\n        if (!info) return;\n        const RenderDialog = DIALOG_CONTENT_TYPES[info?.type];\n        const RenderDialogProps = info.props;\n        return RenderDialog key={`dialog-${info.type}-${idx}`} {...RenderDialogProps} /;\n      })}\n    /\n  );\n};\n\nexport default DialogRoot;\n</span></code></pre><h2><span>3단계: Custom Hook 정의하기</span></h2><p><span>컴포넌트마다 </span><code><span>useContext</span></code><span>를 직접 사용하여 다이얼로그의 컨텍스트를 사용하는 것보다 컨텍스트를 사용하는 목적에 맞게 </span><code><span>Custom hook</span></code><span>으로 분리하여 사용하는 것이 유지보수 측면에서 효율적이다.</span></p><p><code><span>useDialog</span></code><span>와 </span><code><span>useDialogDispatch</span></code><span>라는 Custom Hook을 만들고, 다이얼로그의 컨텍스트를 바탕으로 열고 닫는 로직을 정의한다.</span></p><ul><li><strong><span>showDialog(type, props, error, redirectTo?)</span></strong><ul><li><span>type에 따라 다이얼로그를 열고,</span></li><li><span>필요한 props를 함께 전달한다. 에러 다이얼로그(ERROR 타입)인 경우 에러 정보를 받아 에러 메시지를 표시할 수도 있다.</span></li></ul></li><li><strong><span>hideDialog(to?, all?)</span></strong><ul><li><span>다이얼로그를 닫을 때, 다른 경로의 페이지로 교체해야 한다면 관련 함수를 호출한다.</span></li><li><span>useNavigation의 navigate(to, {replace: true})</span></li><li><span>window.location.replace()</span></li><li><span>all이 true라면 모든 다이얼로그를 닫는다.</span></li></ul></li></ul><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// hooks/dialog.ts\n\nimport { useContext } from 'react';\nimport { DialogType, DialogProps } from 'components/common/dialog/types/DialogTypeMapper';\nimport { DialogContext, DialogDispatchContext } from 'contexts/dialog';\n\nexport function useDialog() {\n  const context = useContext(DialogContext);\n  if (!context) throw new Error('DialogContext is empty.');\n\n  return context;\n}\n\nexport function useDialogDispatch() {\n  const dispatch = useContext(DialogDispatchContext);\n\n  if (!dispatch) throw new Error('Cannot find DialogDispatch');\n\n  const hideDialog = (to?: string, all?: boolean) = {\n    dispatch({\n      type: !!all ? 'HIDE_DIALOG_ALL' : 'HIDE_DIALOG',\n    });\n\n    if (to) {\n      window.location.replace(to);\n    }\n  };\n\n  const showDialog = T extends DialogType(\n    type: T,\n    props?: DialogProps[T],\n    error?: Error,\n    redirectTo?: string\n  ) = {\n    if (type === 'ERROR') {\n      dispatch({\n        type: 'SHOW_ERROR',\n        dialogProps: {\n          ...COMMON_DIALOG_PROPS,\n          ...(props ?? {}),\n        },\n        error: error,\n        redirectTo: redirectTo,\n      });\n      return;\n    }\n\n    dispatch({\n      type: 'SHOW_DIALOG',\n      dialogType: type,\n      dialogProps: {\n        ...COMMON_DIALOG_PROPS,\n        ...(props ?? {}),\n      },\n    });\n  };\n  return { showDialog, hideDialog };\n}\n</span></code></pre><h2><span>4단계: 적용하기</span></h2><p><span>마지막으로 Context, DialogRoot, Custom Hook을 적절히 조합해 애플리케이션에 적용한다.</span></p><ol><li value=\"1\"><span>Provider 세팅: 최상단(예: App 컴포넌트)에서 DialogProvider로 전체를 감싼다.</span></li><li value=\"2\"><span>DialogRoot 등록: 마찬가지로 루트 레벨에 DialogRoot를 배치해, 어느 페이지에서든 다이얼로그가 동일한 위치에 팝업되도록 한다.</span></li><li value=\"3\"><span>사용하는 컴포넌트에서 useDialogDispatch(): 다이얼로그를 열어야 할 때 showDialog나 hideDialog를 호출하면 된다.</span></li></ol><p><span>예시는 다음과 같다:</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// App.tsx\nfunction App() {\n  return (\n    DialogProvider\n      Layout\n        {/* 페이지 콘텐츠들 */}\n      /Layout\n      DialogRoot /\n    /DialogProvider\n  );\n}\n\n// ParentComponent.tsx\nfunction ParentComponent() {\n  const { showDialog } = useDialogDispatch();\n\n  const handleOpenUserDialog = () = {\n    showDialog('USER', {\n      // 필요한 props...\n    });\n  };\n\n  return (\n    button onClick={handleOpenUserDialog}\n      유저 다이얼로그 열기\n    /button\n  );\n}\n</span></code></pre><p><span>이렇게 하면 다이얼로그가 필요한 시점에 쉽게 열 수 있고, props 구조가 달라지거나 에러 처리 로직이 바뀌어도 다이얼로그 자체는 DialogContext와 DialogRoot에서만 수정하면 된다.</span></p><p><span>이 방식의 장점은 다이얼로그 UI 컴포넌트를 특정 컴포넌트에 의존하지 않고 전역에서 한 번에 관리하므로, 유지보수와 확장성에 훨씬 유리하다.</span></p><h2><span>4.5단계: 다이얼로그 상태 미리 업데이트하기 (확장)</span></h2><p><span>위 방식에 추가로, 특정 다이얼로그의 상태를 미리 업데이트하고 필요한 시점에 다이얼로그의 타입만 호출하고 싶을 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// 예시\n\n// contexts/dialog\n\n// ... 코드 생략 ...\n// DialogAction 에 UPDATE_DIALOG 추가\nexport type DialogActionT extends DialogType =\n  | {\n      type: 'SHOW_DIALOG';\n      dialogType: T;\n      dialogProps?: DialogProps[T];\n    }\n  | { type: 'HIDE_DIALOG' }\n  | { type: 'HIDE_DIALOG_ALL' }\n  | {\n      type: 'SHOW_ERROR';\n      dialogProps: DialogProps[T];\n      error?: Error;\n      redirectTo?: string;\n    };\n  | {\n      type: 'UPDATE_DIALOG';\n      dialogType: T;\n\t  updater: (prev?: DialogProps[T] | null) = DialogProps[T];\n      overwrite?: boolean;\n    };\n\n\nfunction dialogReducer(state: Dialog[], action: DialogAction): Dialog[] {\n  switch (action.type) {\n    case 'SHOW_DIALOG': {\n      const { dialogType, dialogProps } = action\n      const existingIndex = state.findIndex((d) = d.type === dialogType);\n\n      if (existingIndex === -1) {\n        // 기존에 없던 다이얼로그라면 새로 생성\n        // 이때 dialogProps는 필수 인자\n        if(!dialogProps){\n        \tthrow new Error(\"새로 생성하는 다이얼로그의 Props가 필요합니다.\")\n        }\n\n        return [\n          ...state,\n          {\n            type: dialogType,\n            props: { ...dialogProps, isOpen: true }\n          },\n        ];\n      } else {\n        // 이미 같은 type의 다이얼로그가 있다면?\n        const existingDialog = state[existingIndex];\n        const mergedProps = {\n          // 기존 props\n          ...existingDialog.props,\n          // 새로 넘어온 props가 있으면 덮어씀\n          ...(props ?? {}),\n          isOpen: true\n        };\n\n        const updatedDialog = {\n          ...existingDialog,\n          props: mergedProps,\n        };\n\n        return [\n          ...state.slice(0, existingIndex),\n          updatedDialog,\n          ...state.slice(existingIndex + 1),\n        ];\n      }\n    }\n\n    case 'UPDATE_DIALOG': {\n      const { dialogType, dialogProps, overwrite } = action as UpdateDialogActionany;\n      // 기존 다이얼로그가 있는지 확인\n      const existingIndex = state.findIndex((d) = d.type === dialogType);\n\n      if (existingIndex === -1) {\n        // 없으면 새로 추가\n        const newDialog = {\n          type: dialogType,\n          props: updater(),\n        };\n        return [...state, newDialog];\n      }\n      // 있으면 업데이트\n      const existingDialog = state[existingIndex];\n\n      // overwrite가 true면 새로 업데이트, false면 기존 props와 병합\n      const baseProps = overwrite ? null : existingDialog.props;\n      const updatedProps = updater(baseProps);\n\n      const updatedDialog = {\n        ...existingDialog,\n        props: updatedProps,\n      };\n\n      return [\n        ...state.slice(0, existingIndex),\n        updatedDialog,\n        ...state.slice(existingIndex + 1),\n      ];\n    }\n\n    default:\n      return state;\n  }\n}\n\n// Hook에서 updateDialog를 제공\nfunction useDialogDispatch() {\n  const dispatch = useContext(DialogDispatchContext);\n\n  function showDialogT extends DialogType(\n    type: T,\n    props?: DialogProps[T],\n    // ... 기타 필요한 파라미터들\n  ) {\n    dispatch({ type: 'SHOW_DIALOG', dialogType: type, dialogProps: props });\n  }\n\n  function updateDialogT extends DialogType(\n    type: T,\n    updater: (prev?: DialogProps[T] | null) = DialogProps[T],\n    overwrite?: boolean,\n  ) {\n    dispatch({ type: 'UPDATE_DIALOG', dialogType: type, updater, overwrite });\n  }\n\n  // hideDialog 등 다른 함수들\n\n  return { showDialog, updateDialog /* ... */ };\n}\n\n</span></code></pre><p><span>이렇게 구현해두면, 특정 컴포넌트에서 updateDialog를 호출해 미리 특정 다이얼로그의 props를 설정해둘 수 있다. 그리고 다이얼로그를 여는 시점에는 openDialog([\"다이얼로그 타입\"]) 으로만 호출할 수 있다.</span></p><p><span>예를 들어 다음과 같이 작성할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// ParentComponent.tsx\nimport { useEffect } from 'react';\nimport { useDialogDispatch } from './hooks/dialog';\n\nfunction ParentComponent() {\n  const { showDialog, updateDialog } = useDialogDispatch();\n  const [userName, setUserName] = useState('홍길동');\n  const [userAge, setUserAge] = useState(20);\n  const [userAddress, setUserAddress] = useState('서울');\n\n  // 사용자 정보 fetch 등으로 업데이트\n  useEffect(() = {\n    updateDialog('USER', (prev) = ({\n      ...(prev ?? {}),\n      user: {\n        name: userName,\n        age: userAge,\n        address: userAddress,\n      },\n    }), true);\n  }, [userName, userAge, userAddress, updateDialog]);\n\n  const handleOpenUserDialog = () = {\n    // 여기서는 다이얼로그 타입만 넘겨주어도 된다.\n    showDialog('USER');\n  };\n\n  return (\n    button onClick={handleOpenUserDialog}\n    \t{\"복잡한 다이얼로그 열기\"}\n    /button\n  );\n}\n</span></code></pre><p><span>이런 식으로 미리 다이얼로그의 상태를 업데이트해두면, 다이얼로그를 여는 시점에서는 단순히 \"어떤 다이얼로그인지\"만 지정하면 되므로 코드가 좀 더 깔끔해진다.</span></p><p><span>하지만 이런 방식의 단점 또한 존재하는데, 일단 코드의 복잡도는 당연히 더 올라갔으며 파편화가 심해지면 다이얼로그의 상태가 어느 시점에 업데이트 되는지 알기 더욱 어려워진다.</span></p><p><span>결국 </span><strong><span>다이얼로그를 \"보여준다.\"는 것 역시 다이얼로그의 isOpen 상태를 업데이트하는 것이므로</span></strong><span> show와 update를 구분하는 것과 show 하나로 상태 업데이트를 모두 담당하도록 하는 방법에는 프로젝트의 성격이나 사용 방식에 따라 조율이 필요해 보인다.</span></p><h1><span>결론</span></h1><p><span>이 글에서는 Context와 Custom Hook을 활용해 다이얼로그를 선언형으로 관리하는 과정을 살펴보았다.</span></p><p><span>(1) Context 정의 → (1.5) 타입 설계(선택) → (2) DialogRoot → (3) Custom Hook → (4) 적용 순으로 정리한 뒤, (4.5) 미리 다이얼로그 상태를 업데이트해두는 확장 방법도 알아보았다.</span></p><h1><span>다이얼로그는 포스트잇이다.</span></h1><p><span>이전 회사에서 같이 일했던 팀원이 말씀해주신 건데, 적절한 비유라고 생각해서 기억하고 있다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/e62023b6-c555-43ab-a896-cac04b499469/image.png\" alt=\"undefined\" /><p><span>포스트잇처럼 쉽게 떼고 붙일 수 있는 것이 다이얼로그인만큼 기존 App의 컨텍스트에 영향을 주지 않으면서 </span><strong><span>변경 사항에 유연한 대응이 가능한 확장성 있는 구조로 설계해야</span></strong><span> 비로소 다이얼로그를 컴포넌트화 하는 의미가 생기는 것 같다.</span></p>"}},"pageContext":{"id":"6143e96e-a35d-5214-9af0-e055c1ee295c","title":"[React] 끈적거리는 다이얼로그 선언적으로 관리하기","contentHtml":"<ul><li><span>본 글은 모달과 다이얼로그의 개념을 엄밀하게 구분하지 않고 혼용해서 사용하고 있으니 참고해주세요. 팝업 UI를 모두 다이얼로그로 지칭하고 있습니다.</span></li></ul><h1><span>배경</span></h1><p><span>전 회사에서 근무했을 때, 아래와 같은 코드를 발견했다. 다른 로직들은 다 제거하고 다이얼로그와 관련된 코드 예시다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">\nimport { useState } from 'react';\n\nimport AlertDialog from '@component/dialog';\n\nconst Component = () = {\n   const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    div\n      button onClick={() = {setIsOpen(true)}} 버튼 /button\n      {isOpen && AlertDialog / }\n    /div\n\n  )\n\n}\n</span></code></pre><p><span>위 코드에서 </span><strong><span>AlertDialog</span></strong><span>는 웹페이지에서 어떤 버튼을 클릭했을 때, 사용자에게 정보를 알려주는 다이얼로그다. 대충 아래의 다이얼로그와 비슷한 경우라고 할 수 있다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/8abdbeda-2d08-4d06-9d17-94e0da9d83dc/image.png\" alt=\"undefined\" /><p><span>간단한 다이얼로그를 사용하는 경우라면 크게 상관 없을 지도 모른다. 하지만 세상 일이라는 것이 단순하면서도 단순하지 않다.</span></p><h1><span>문제 상황: 끈적거리는 다이얼로그</span></h1><p><span>위의 예시처럼 정해진 정보를 사용자에게 알려주고, 확인 버튼을 누르면 닫는 방식의 다이얼로그는 외부에서 전달 받는 데이터가 없다.</span></p><p><span>하지만 아래와 같이 다이얼로그에 따라 다이얼로그 외부의 데이터를 전달받아야 하는 상황이 발생할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import React from 'react';\n\ntype UserData = {\n  name: string;\n  age: number;\n  address: string;\n};\n\ntype MyComplexDialogProps = {\n  isOpen: boolean;\n  user: UserData;\n  errorMessages: string[];\n  currentStep: number;\n  isVerified: boolean;\n  isLoading: boolean;\n  onConfirm: () = void;\n  onCancel: () = void;\n  onRetry: () = void;\n};\n\nfunction MyComplexDialog({\n  isOpen,\n  user,\n  errorMessages,\n  currentStep,\n  isVerified,\n  isLoading,\n  onConfirm,\n  onCancel,\n  onRetry,\n}: MyComplexDialogProps) {\n  if (!isOpen) return null;\n\n  return (\n    div\n      style={{\n        border: '1px solid #ccc',\n        padding: '16px',\n        backgroundColor: '#fff',\n      }}\n    \n      h2복잡한 다이얼로그/h2\n      p현재 스텝: {currentStep}/p\n      p사용자 이름: {user.name}/p\n      p나이: {user.age}/p\n      p주소: {user.address}/p\n      p인증 여부: {isVerified ? '인증됨' : '인증 안됨'}/p\n\n      {errorMessages.length  0 && (\n        div style={{ color: 'red' }}\n          h3에러 메시지/h3\n          ul\n            {errorMessages.map((msg, idx) = (\n              li key={idx}{msg}/li\n            ))}\n          /ul\n        /div\n      )}\n\n      div\n        button onClick={onConfirm} disabled={isLoading}\n          확인\n        /button\n        button onClick={onCancel}취소/button\n        {!isVerified && (\n          button onClick={onRetry} disabled={isLoading}\n            재시도\n          /button\n        )}\n      /div\n    /div\n  );\n}\n\nexport default MyComplexDialog;\n\n</span></code></pre><p><span>다이얼로그를 사용하는 컴포넌트 </span><code><span>ParentComponent</span></code><span> 는 이 다이얼로그를 사용하기 위해 필요한 데이터를 관리하고 트리거하여 전달한다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import React, { useState } from 'react';\nimport MyComplexDialog from './MyComplexDialog'; // 다이얼로그 import\n\nfunction ParentComponent() {\n  // 사용자 관련 상태\n  const [userName, setUserName] = useState('홍길동');\n  const [userAge, setUserAge] = useState(20);\n  const [userAddress, setUserAddress] = useState('서울');\n\n  // 에러 관련 상태\n  const [errorMessages, setErrorMessages] = useStatestring[]([]);\n\n  // 다이얼로그 노출 상태\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\n\n  // 인증 상태, 로딩 상태\n  const [isVerified, setIsVerified] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // 단계 관리\n  const [currentStep, setCurrentStep] = useState(1);\n\n  // 다이얼로그 열기\n  const handleOpenDialog = () = {\n    setIsDialogOpen(true);\n  };\n\n  // 다이얼로그 닫기\n  const handleCloseDialog = () = {\n    setIsDialogOpen(false);\n    // 다이얼로그를 닫을 때, 에러 초기화나 단계도 초기화할 수 있음\n    setErrorMessages([]);\n    setCurrentStep(1);\n  };\n\n  // 확인(확정) 버튼\n  const handleConfirm = () = {\n    // 확인 시 로직 예시\n    if (!isVerified) {\n      setErrorMessages((prev) = [...prev, '아직 인증되지 않았습니다.']);\n      return;\n    }\n    alert('확인되었습니다!');\n    handleCloseDialog();\n  };\n\n  // 재시도 버튼\n  const handleRetry = async () = {\n    setIsLoading(true);\n    // 인증 재시도 로직 예시 (가짜 타이머)\n    setTimeout(() = {\n      setIsVerified(true);\n      setIsLoading(false);\n      setCurrentStep((step) = step + 1);\n    }, 1000);\n  };\n\n  return (\n    div\n      h1다이얼로그 사용 예시/h1\n      p이름: {userName}/p\n      p나이: {userAge}/p\n      p주소: {userAddress}/p\n\n      button onClick={handleOpenDialog}복잡한 다이얼로그 열기/button\n\n      MyComplexDialog\n        // 다이얼로그 열림 여부\n        isOpen={isDialogOpen}\n        // 사용자 정보\n        user={{\n          name: userName,\n          age: userAge,\n          address: userAddress,\n        }}\n        // 에러 목록\n        errorMessages={errorMessages}\n        // 현재 단계, 인증 여부, 로딩 상태\n        currentStep={currentStep}\n        isVerified={isVerified}\n        isLoading={isLoading}\n        // 콜백 함수\n        onConfirm={handleConfirm}\n        onCancel={handleCloseDialog}\n        onRetry={handleRetry}\n      /\n    /div\n  );\n}\n\nexport default ParentComponent;\n\n</span></code></pre><p><span>MyComplexDialog 다이얼로그를 트리거하여 state를 props로 전달해야 할 필요는 알겠지만, 이런 방식으로 전달하는 방법은 언뜻 봐도 문제가 있어 보인다.</span></p><p><span>또한 UI 컴포넌트는 필요하다면 API 서버와 통신하여 데이터를 fetch 하는 로직도 필요하다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-right-bracket=\"true\">import { useEffect } from 'react';\n\nfunction ParentComponent() {\n  // 사용자 관련 상태\n  const [userName, setUserName] = useState('홍길동');\n  const [userAge, setUserAge] = useState(20);\n  const [userAddress, setUserAddress] = useState('서울');\n\n  // ... 중략 ...\n\n  // User data fetch\n  useEffect(() ={\n  \tasync function fetchUserData() = {\n    \tconst response = await fetch('url');\n      \tconst data = await response.json();\n\n      \tsetUserName(data.userName);\n      \tsetUserAge(data.userAge);\n      \tsetUserAddress(data.userAddress)\n    }\n    fetchUserData();\n  }, [])\n\n  // ... 중략 ...\n\n}\n</span></code></pre><p><code><span>ParentComponent</span></code><span>에 </span><code><span>MyComplexDialog</span></code><span>와는 관계 없는 state와 effect 로직이 많아질수록, 언제 사용될지 모르는 </span><code><span>MyComplexDialog</span></code><span>가 껌딱지처럼 </span><code><span>ParentComponent</span></code><span> 코드에 달라붙어있는 모습은 유지보수와 확장에 큰 악영향을 준다.</span></p><p><span>만약 둘 중 하나라도 코드를 수정해야 하는 상황이 된다면, 예를 들어 적어도 props 중 전달받는 data의 타입이 달라지는 상황에 처한다면 다이얼로그의 Props 타입을 슬쩍 수정한 것만으로도 파일 목록에 시뻘건 줄이 그어져 있는 모습을 마주할 수 있을 것이다.</span></p><h1><span>문제 해결 목표</span></h1><p><span>다이얼로그를 최대한 덜 끈적거리게 사용하는 방법을 </span><code><span>Context API</span></code><span>와 </span><code><span>Custom Hook</span></code><span>을 통해 구현해보고자 한다.</span></p><p><span>Context API는 컴포넌트 간 상태 공유를 위해 사용하는 것이므로 필요에 맞게 zustand, recoil 같은 클라이언트 상태 관리 라이브러리로 대체하면 구현이 훨씬 간편해질 수 있다.</span></p><p><span>하지만 팀 상황에 따라 React의 기본 인터페이스로만 우선 작업해야 하는 경우가 있으므로, Context API로 구현해본다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import { useEffect } from 'react';\n\nimport { useDialogAction } from './hooks';\nimport { DialogTypes } from './dialog';\n\n\nfunction ParentComponent(){\n  // ... 생략 ...\n  const { openDialog, closeDialog, updateDialog } = useDialogAction();\n\n  // User data fetch\n  useEffect(() ={\n  \tasync function fetchUserData() = {\n    \tconst response = await fetch('url');\n      \tconst data = await response.json();\n\n      \tsetUserName(data.userName);\n      \tsetUserAge(data.userAge);\n      \tsetUserAddress(data.userAddress)\n    }\n\n    fetchUserData();\n  }, [])\n\n  // Dialog 상태 업데이트(option)\n  useEffect(() = {\n    updateDialog(DialogTypes.User, (prev) = ({\n    \t...prev,\n      \tuser: {\n        \tname: userName,\n          \tage: userAge,\n          \taddress: userAddress\n        }\n    }), true);\n  }, [userName, userAge, useAddress])\n\n  return (\n    div\n      h1다이얼로그 사용 예시/h1\n      p이름: {userName}/p\n      p나이: {userAge}/p\n      p주소: {userAddress}/p\n\n      button onClick={() = {\n        openDialog(DialogTypes.User)\n    \t}}\n        복잡한 다이얼로그 열기\n      /button\n    /div\n  );\n\n}\n\n</span></code></pre><h2><span>1단계: Context 정의하기</span></h2><p><span>먼저 다이얼로그 관리를 위한 Context를 정의한다. </span><code><span>createContext</span></code><span>와 </span><code><span>useReducer</span></code><span>를 조합해 사용하며, 여기서는 다이얼로그가 여러 개 동시에 열릴 수 있다는 점을 고려해 다이얼로그 상태를 배열 형태로 관리한다.</span></p><ul><li><code><span>DialogContext</span></code><span>에서는 현재 열려 있는 다이얼로그 배열을 조회하고,</span></li><li><code><span>DialogDispatchContext</span></code><span>에서는 다이얼로그를 열거나 닫는 액션을 수행한다.</span></li></ul><p><span>이렇게 Context를 두 가지로 나누는 이유는, **읽기(dialog 상태 조회)와 쓰기(dispatch로 액션 전달)를 분리하기 위해서다. **</span></p><p><span>아래 예시처럼 </span><code><span>DialogProvider</span></code><span>를 구현하고, 내부에서 reducer를 통해 dialog 상태와 액션을 관리한다. 또한 뒤로 가기(브라우저 히스토리 popstate)가 발생하면 모든 다이얼로그를 닫도록 처리해, 다이얼로그가 브라우저 이동 히스토리에 끼어들지 않도록 한다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// contexts/dialog\n\nimport React, { createContext, Dispatch, useEffect, useReducer } from 'react';\nimport { DialogType, DialogProps } from 'components/common/dialog/types';\n\nexport type Dialog = {\n  type: DialogType;\n  props: DialogProps[DialogType];\n} | null;\n\nexport type DialogActionT extends DialogType =\n  | {\n      type: 'SHOW_DIALOG';\n      dialogType: T;\n      dialogProps: DialogProps[T];\n    }\n  | { type: 'HIDE_DIALOG' }\n  | { type: 'HIDE_DIALOG_ALL' }\n  | {\n      type: 'SHOW_ERROR';\n      dialogProps: DialogProps[T];\n      error?: Error;\n      redirectTo?: string;\n    };\n\ntype DialogContextType = {\n  dialog: Dialog[];\n} | null;\n\nexport const DialogContext = createContextDialogContextType(null);\nexport const DialogDispatchContext = createContext\n  DispatchDialogActionDialogType | undefined\n(undefined);\n\nfunction reducer(dialog: Dialog[], action: DialogActionDialogType): Dialog[] {\n  switch (action.type) {\n    case 'SHOW_DIALOG':\n      return [\n        ...dialog,\n        {\n          type: action.dialogType,\n          props: { ...action.dialogProps, isOpen: true },\n        },\n      ];\n    case 'HIDE_DIALOG':\n      return dialog.slice(0, -1);\n    case 'HIDE_DIALOG_ALL':\n      return [];\n    case 'SHOW_ERROR':\n      return [\n        ...dialog,\n        {\n          type: 'ERROR',\n          props: {\n            ...action.dialogProps,\n            isOpen: true,\n            title: action.error?.title,\n            message: action.error?.message,\n            redirectTo: action.redirectTo,\n          },\n        },\n      ];\n    default:\n      return dialog;\n  }\n}\nexport function DialogProvider({ children }: { children: React.ReactNode }) {\n  const [dialog, dispatch] = useReducer(reducer, []);\n\n  useEffect(() = {\n    const handlePopState = () = {\n      dispatch({ type: 'HIDE_DIALOG_ALL' });\n    };\n\n    window.addEventListener('popstate', handlePopState);\n\n    return () = {\n      window.removeEventListener('popstate', handlePopState);\n    };\n  }, [dispatch]);\n\n  return (\n    DialogContext.Provider value={{ dialog }}\n      DialogDispatchContext.Provider value={dispatch}\n        {children}\n      /DialogDispatchContext.Provider\n    /DialogContext.Provider\n  );\n}\n\n</span></code></pre><h2><span>1.5단계: Dialog와 Dialog Component Props 타입 구조화하기 (선택)</span></h2><p><span>다이얼로그가 많아지면 다이얼로그 별로 필요한 props가 달라 복잡해지기 쉽다. 이 문제는 TypeScript를 사용하면 쉽게 해결할 수 있다.</span></p><p><span>예를 들어 다이얼로그 타입을 미리 정의하고, DialogType별로 필요한 props를 모아두는 전략을 취할 수 있다.</span></p><p><span>DialogTypeMapper 객체를 만들어 다음과 같이 작성해보자.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span>export const DialogTypeMapper = {\n  Confirm: 'CONFIRM',\n  Error: 'ERROR',\n  User: 'USER',\n} as const;\n\nexport type DialogType = (typeof DialogTypeMapper)[keyof typeof DialogTypeMapper];\n</span></code></pre><p><span>이렇게 문자열 리터럴 타입을 만들고, 각 다이얼로그 종류별로 필요한 props를 </span><code><span>DialogProps</span></code><span>라는 매핑 타입에 정리한다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span>export type DialogProps = {\n  CONFIRM: ConfirmDialogProps;\n  ERROR: ErrorDialogProps;\n  USER: UserDialogProps;\n};\n</span></code></pre><p><span>이렇게 정리하면, 다이얼로그가 많아질수록 props 관리가 훨씬 명확해진다. props 구조가 바뀌면, 다이얼로그를 사용하는 쪽에서 타입 에러를 통해 문제를 빠르게 찾을 수 있기 때문이다.</span></p><p><span>만약 새로운 다이얼로그를 생성하고자 한다면 아래와 같이 Props를 지정해줄 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// 코드 예시\n\nimport { useEffect, useState } from 'react';\nimport type { DialogProps } from './types';\n\nexport const ConfirmDialog = ({\n  isOpen = false,\n  onClose,\n  title,\n  message,\n  ok,\n  cancel,\n  hideOk,\n  textInput,\n  width = 360,\n  height,\n  onKeyUp,\n}: DialogProps['CONFIRM']) = {\n  const [text, setText] = useState('');\n\n  return (\n    Dialog\n      open={isOpen}\n      onClose={onClose}\n      onKeyUp={onKeyUp}\n    \n\t\t{...}\n    /Dialog\n  );\n};\n</span></code></pre><h2><span>2단계: Render Dialog Root Component 생성하기</span></h2><p><span>Context에 저장된 다이얼로그 배열을 실제로 렌더링할 컴포넌트를 만드는 방법이다.</span></p><p><span>예를 들어 </span><code><span>DialogRoot</span></code><span>라는 컴포넌트를 만들어, dialog 상태를 순회하면서 알맞은 다이얼로그 컴포넌트를 매핑한다.</span></p><p><span>dialog 배열에는 </span><code><span>{ type, props }</span></code><span> 형태의 객체가 들어 있다.</span></p><p><span>type을 통해 어떤 다이얼로그인지 식별하고,</span></p><p><span>그에 맞는 컴포넌트를 </span><code><span>DIALOG_CONTENT_TYPES</span></code><span> 객체에서 가져와 렌더링한다.</span></p><p><span>이렇게 공통 Root를 두면, 다양한 다이얼로그를 한 곳에서 일괄 관리할 수 있다.</span></p><ul><li><span>*예를들어, ConfirmDialog, AlertDialog, UserDialog 등 여러 다이얼로그를 한꺼번에 매핑해줄 수 있다.\n**</span></li></ul><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">import { DialogType } from 'components/common/dialog/types/DialogTypeMapper.ts';\nimport { useDialog } from 'hooks/dialog';\nimport {\n  ConfirmDialog,\n  UserDialog,\n // ...\n} from '../common/dialog';\n\nconst DIALOG_CONTENT_TYPES: { [key in DialogType]: any } = {\n  USER: UserDialog,\n  CONFIRM: ConfirmDialog,\n};\n\nconst DialogRoot = () = {\n  const context = useDialog();\n  const { dialog } = context;\n\n  if (!dialog) return /;\n\n  return (\n    \n      {dialog.map((info, idx) = {\n        if (!info) return;\n        const RenderDialog = DIALOG_CONTENT_TYPES[info?.type];\n        const RenderDialogProps = info.props;\n        return RenderDialog key={`dialog-${info.type}-${idx}`} {...RenderDialogProps} /;\n      })}\n    /\n  );\n};\n\nexport default DialogRoot;\n</span></code></pre><h2><span>3단계: Custom Hook 정의하기</span></h2><p><span>컴포넌트마다 </span><code><span>useContext</span></code><span>를 직접 사용하여 다이얼로그의 컨텍스트를 사용하는 것보다 컨텍스트를 사용하는 목적에 맞게 </span><code><span>Custom hook</span></code><span>으로 분리하여 사용하는 것이 유지보수 측면에서 효율적이다.</span></p><p><code><span>useDialog</span></code><span>와 </span><code><span>useDialogDispatch</span></code><span>라는 Custom Hook을 만들고, 다이얼로그의 컨텍스트를 바탕으로 열고 닫는 로직을 정의한다.</span></p><ul><li><strong><span>showDialog(type, props, error, redirectTo?)</span></strong><ul><li><span>type에 따라 다이얼로그를 열고,</span></li><li><span>필요한 props를 함께 전달한다. 에러 다이얼로그(ERROR 타입)인 경우 에러 정보를 받아 에러 메시지를 표시할 수도 있다.</span></li></ul></li><li><strong><span>hideDialog(to?, all?)</span></strong><ul><li><span>다이얼로그를 닫을 때, 다른 경로의 페이지로 교체해야 한다면 관련 함수를 호출한다.</span></li><li><span>useNavigation의 navigate(to, {replace: true})</span></li><li><span>window.location.replace()</span></li><li><span>all이 true라면 모든 다이얼로그를 닫는다.</span></li></ul></li></ul><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// hooks/dialog.ts\n\nimport { useContext } from 'react';\nimport { DialogType, DialogProps } from 'components/common/dialog/types/DialogTypeMapper';\nimport { DialogContext, DialogDispatchContext } from 'contexts/dialog';\n\nexport function useDialog() {\n  const context = useContext(DialogContext);\n  if (!context) throw new Error('DialogContext is empty.');\n\n  return context;\n}\n\nexport function useDialogDispatch() {\n  const dispatch = useContext(DialogDispatchContext);\n\n  if (!dispatch) throw new Error('Cannot find DialogDispatch');\n\n  const hideDialog = (to?: string, all?: boolean) = {\n    dispatch({\n      type: !!all ? 'HIDE_DIALOG_ALL' : 'HIDE_DIALOG',\n    });\n\n    if (to) {\n      window.location.replace(to);\n    }\n  };\n\n  const showDialog = T extends DialogType(\n    type: T,\n    props?: DialogProps[T],\n    error?: Error,\n    redirectTo?: string\n  ) = {\n    if (type === 'ERROR') {\n      dispatch({\n        type: 'SHOW_ERROR',\n        dialogProps: {\n          ...COMMON_DIALOG_PROPS,\n          ...(props ?? {}),\n        },\n        error: error,\n        redirectTo: redirectTo,\n      });\n      return;\n    }\n\n    dispatch({\n      type: 'SHOW_DIALOG',\n      dialogType: type,\n      dialogProps: {\n        ...COMMON_DIALOG_PROPS,\n        ...(props ?? {}),\n      },\n    });\n  };\n  return { showDialog, hideDialog };\n}\n</span></code></pre><h2><span>4단계: 적용하기</span></h2><p><span>마지막으로 Context, DialogRoot, Custom Hook을 적절히 조합해 애플리케이션에 적용한다.</span></p><ol><li value=\"1\"><span>Provider 세팅: 최상단(예: App 컴포넌트)에서 DialogProvider로 전체를 감싼다.</span></li><li value=\"2\"><span>DialogRoot 등록: 마찬가지로 루트 레벨에 DialogRoot를 배치해, 어느 페이지에서든 다이얼로그가 동일한 위치에 팝업되도록 한다.</span></li><li value=\"3\"><span>사용하는 컴포넌트에서 useDialogDispatch(): 다이얼로그를 열어야 할 때 showDialog나 hideDialog를 호출하면 된다.</span></li></ol><p><span>예시는 다음과 같다:</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// App.tsx\nfunction App() {\n  return (\n    DialogProvider\n      Layout\n        {/* 페이지 콘텐츠들 */}\n      /Layout\n      DialogRoot /\n    /DialogProvider\n  );\n}\n\n// ParentComponent.tsx\nfunction ParentComponent() {\n  const { showDialog } = useDialogDispatch();\n\n  const handleOpenUserDialog = () = {\n    showDialog('USER', {\n      // 필요한 props...\n    });\n  };\n\n  return (\n    button onClick={handleOpenUserDialog}\n      유저 다이얼로그 열기\n    /button\n  );\n}\n</span></code></pre><p><span>이렇게 하면 다이얼로그가 필요한 시점에 쉽게 열 수 있고, props 구조가 달라지거나 에러 처리 로직이 바뀌어도 다이얼로그 자체는 DialogContext와 DialogRoot에서만 수정하면 된다.</span></p><p><span>이 방식의 장점은 다이얼로그 UI 컴포넌트를 특정 컴포넌트에 의존하지 않고 전역에서 한 번에 관리하므로, 유지보수와 확장성에 훨씬 유리하다.</span></p><h2><span>4.5단계: 다이얼로그 상태 미리 업데이트하기 (확장)</span></h2><p><span>위 방식에 추가로, 특정 다이얼로그의 상태를 미리 업데이트하고 필요한 시점에 다이얼로그의 타입만 호출하고 싶을 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// 예시\n\n// contexts/dialog\n\n// ... 코드 생략 ...\n// DialogAction 에 UPDATE_DIALOG 추가\nexport type DialogActionT extends DialogType =\n  | {\n      type: 'SHOW_DIALOG';\n      dialogType: T;\n      dialogProps?: DialogProps[T];\n    }\n  | { type: 'HIDE_DIALOG' }\n  | { type: 'HIDE_DIALOG_ALL' }\n  | {\n      type: 'SHOW_ERROR';\n      dialogProps: DialogProps[T];\n      error?: Error;\n      redirectTo?: string;\n    };\n  | {\n      type: 'UPDATE_DIALOG';\n      dialogType: T;\n\t  updater: (prev?: DialogProps[T] | null) = DialogProps[T];\n      overwrite?: boolean;\n    };\n\n\nfunction dialogReducer(state: Dialog[], action: DialogAction): Dialog[] {\n  switch (action.type) {\n    case 'SHOW_DIALOG': {\n      const { dialogType, dialogProps } = action\n      const existingIndex = state.findIndex((d) = d.type === dialogType);\n\n      if (existingIndex === -1) {\n        // 기존에 없던 다이얼로그라면 새로 생성\n        // 이때 dialogProps는 필수 인자\n        if(!dialogProps){\n        \tthrow new Error(\"새로 생성하는 다이얼로그의 Props가 필요합니다.\")\n        }\n\n        return [\n          ...state,\n          {\n            type: dialogType,\n            props: { ...dialogProps, isOpen: true }\n          },\n        ];\n      } else {\n        // 이미 같은 type의 다이얼로그가 있다면?\n        const existingDialog = state[existingIndex];\n        const mergedProps = {\n          // 기존 props\n          ...existingDialog.props,\n          // 새로 넘어온 props가 있으면 덮어씀\n          ...(props ?? {}),\n          isOpen: true\n        };\n\n        const updatedDialog = {\n          ...existingDialog,\n          props: mergedProps,\n        };\n\n        return [\n          ...state.slice(0, existingIndex),\n          updatedDialog,\n          ...state.slice(existingIndex + 1),\n        ];\n      }\n    }\n\n    case 'UPDATE_DIALOG': {\n      const { dialogType, dialogProps, overwrite } = action as UpdateDialogActionany;\n      // 기존 다이얼로그가 있는지 확인\n      const existingIndex = state.findIndex((d) = d.type === dialogType);\n\n      if (existingIndex === -1) {\n        // 없으면 새로 추가\n        const newDialog = {\n          type: dialogType,\n          props: updater(),\n        };\n        return [...state, newDialog];\n      }\n      // 있으면 업데이트\n      const existingDialog = state[existingIndex];\n\n      // overwrite가 true면 새로 업데이트, false면 기존 props와 병합\n      const baseProps = overwrite ? null : existingDialog.props;\n      const updatedProps = updater(baseProps);\n\n      const updatedDialog = {\n        ...existingDialog,\n        props: updatedProps,\n      };\n\n      return [\n        ...state.slice(0, existingIndex),\n        updatedDialog,\n        ...state.slice(existingIndex + 1),\n      ];\n    }\n\n    default:\n      return state;\n  }\n}\n\n// Hook에서 updateDialog를 제공\nfunction useDialogDispatch() {\n  const dispatch = useContext(DialogDispatchContext);\n\n  function showDialogT extends DialogType(\n    type: T,\n    props?: DialogProps[T],\n    // ... 기타 필요한 파라미터들\n  ) {\n    dispatch({ type: 'SHOW_DIALOG', dialogType: type, dialogProps: props });\n  }\n\n  function updateDialogT extends DialogType(\n    type: T,\n    updater: (prev?: DialogProps[T] | null) = DialogProps[T],\n    overwrite?: boolean,\n  ) {\n    dispatch({ type: 'UPDATE_DIALOG', dialogType: type, updater, overwrite });\n  }\n\n  // hideDialog 등 다른 함수들\n\n  return { showDialog, updateDialog /* ... */ };\n}\n\n</span></code></pre><p><span>이렇게 구현해두면, 특정 컴포넌트에서 updateDialog를 호출해 미리 특정 다이얼로그의 props를 설정해둘 수 있다. 그리고 다이얼로그를 여는 시점에는 openDialog([\"다이얼로그 타입\"]) 으로만 호출할 수 있다.</span></p><p><span>예를 들어 다음과 같이 작성할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// ParentComponent.tsx\nimport { useEffect } from 'react';\nimport { useDialogDispatch } from './hooks/dialog';\n\nfunction ParentComponent() {\n  const { showDialog, updateDialog } = useDialogDispatch();\n  const [userName, setUserName] = useState('홍길동');\n  const [userAge, setUserAge] = useState(20);\n  const [userAddress, setUserAddress] = useState('서울');\n\n  // 사용자 정보 fetch 등으로 업데이트\n  useEffect(() = {\n    updateDialog('USER', (prev) = ({\n      ...(prev ?? {}),\n      user: {\n        name: userName,\n        age: userAge,\n        address: userAddress,\n      },\n    }), true);\n  }, [userName, userAge, userAddress, updateDialog]);\n\n  const handleOpenUserDialog = () = {\n    // 여기서는 다이얼로그 타입만 넘겨주어도 된다.\n    showDialog('USER');\n  };\n\n  return (\n    button onClick={handleOpenUserDialog}\n    \t{\"복잡한 다이얼로그 열기\"}\n    /button\n  );\n}\n</span></code></pre><p><span>이런 식으로 미리 다이얼로그의 상태를 업데이트해두면, 다이얼로그를 여는 시점에서는 단순히 \"어떤 다이얼로그인지\"만 지정하면 되므로 코드가 좀 더 깔끔해진다.</span></p><p><span>하지만 이런 방식의 단점 또한 존재하는데, 일단 코드의 복잡도는 당연히 더 올라갔으며 파편화가 심해지면 다이얼로그의 상태가 어느 시점에 업데이트 되는지 알기 더욱 어려워진다.</span></p><p><span>결국 </span><strong><span>다이얼로그를 \"보여준다.\"는 것 역시 다이얼로그의 isOpen 상태를 업데이트하는 것이므로</span></strong><span> show와 update를 구분하는 것과 show 하나로 상태 업데이트를 모두 담당하도록 하는 방법에는 프로젝트의 성격이나 사용 방식에 따라 조율이 필요해 보인다.</span></p><h1><span>결론</span></h1><p><span>이 글에서는 Context와 Custom Hook을 활용해 다이얼로그를 선언형으로 관리하는 과정을 살펴보았다.</span></p><p><span>(1) Context 정의 → (1.5) 타입 설계(선택) → (2) DialogRoot → (3) Custom Hook → (4) 적용 순으로 정리한 뒤, (4.5) 미리 다이얼로그 상태를 업데이트해두는 확장 방법도 알아보았다.</span></p><h1><span>다이얼로그는 포스트잇이다.</span></h1><p><span>이전 회사에서 같이 일했던 팀원이 말씀해주신 건데, 적절한 비유라고 생각해서 기억하고 있다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/e62023b6-c555-43ab-a896-cac04b499469/image.png\" alt=\"undefined\" /><p><span>포스트잇처럼 쉽게 떼고 붙일 수 있는 것이 다이얼로그인만큼 기존 App의 컨텍스트에 영향을 주지 않으면서 </span><strong><span>변경 사항에 유연한 대응이 가능한 확장성 있는 구조로 설계해야</span></strong><span> 비로소 다이얼로그를 컴포넌트화 하는 의미가 생기는 것 같다.</span></p>"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}