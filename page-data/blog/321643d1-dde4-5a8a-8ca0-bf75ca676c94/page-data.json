{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/321643d1-dde4-5a8a-8ca0-bf75ca676c94/","result":{"data":{"site":{"siteMetadata":{"title":"KSoonYo Blog"}},"notionPage":{"title":"[Typescript] Array와 Tuple의 length 타입 차이? + 제네릭 타입의 특정 프로퍼티 체크하는 방법","contentHtml":"<h1><span>TL;DR;</span></h1><ul><li><span>&와 keyof를 사용하여 타입의 특정 프로퍼티를 체크할 수 있다.</span></li><li><span>Array의 length는 number</span></li><li><span>Tuple의 length는 숫자형 리터럴</span></li></ul><h1><span>length 프로퍼티 체크</span></h1><p><span>제네릭 타입을 사용하는 중에 해당 타입의 특정 프로퍼티가 있는지를 체크하고 싶다면, & 인터섹션과 keyof를 활용하여 구현할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type AT = T['property' & keyof T]\n</span></code></pre><p><span>원리는 간단하다.</span></p><ol><li value=\"1\"><span>T 제네릭 타입에 keyof를 하면 </span><strong><span>T 타입의 프로퍼티가 유니온 타입으로 변환된다.</span></strong></li><li value=\"2\"><span data-right-bracket=\"true\">이 유니온 타입의 인터섹션을 내가 체크하고 싶은 프로퍼티 명으로 하면 해당 프로퍼티만 남는다. - </span><strong><span>만약 인터섹션이 되지 않으면 never 타입이 된다.</span></strong></li><li value=\"3\"><strong><span>2번에서 추출한 프로퍼티로 T 타입에 indexed access를 하여 해당 프로퍼티의 타입으로 최종 결정된다.</span></strong></li></ol><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type AT = T['property' & keyof T]\n\ntype Example = {'property': number, 'rest': string}\ntype Example2 = {a: number}\n\ntype Foo = AExample // number\n\ntype Bar = AExample2 // never\n\n</span></code></pre><p><span>위 예시에서 </span><code><span>Foo</span></code><span> 타입은</span></p><ol><li value=\"1\"><code><span data-left-bracket=\"true\" data-right-bracket=\"true\">AExample = Example['property' & keyof T]</span></code><span> 타입으로 정의된다.</span></li><li value=\"2\"><code><span>Example['property' & keyof T]</span></code><span> 는 </span><code><span>Example['property' & ('property' | 'rest')]</span></code><span>와 같다.</span></li><li value=\"3\"><span>Example 타입에는 </span><code><span>'property'</span></code><span> 프로퍼티 속성이 있으므로 해당 프로퍼티 속성의 타입이 인터섹션의 결과로 남는다.</span></li><li value=\"4\"><code><span>Example['property']</span></code><span>는 number 타입에 해당하므로 최종적으로 </span><code><span>Foo</span></code><span>는 number 타입으로 정의된다.</span></li></ol><p><span>이러한 원리를 이용하여 아래와 같이 T 제네릭 타입에 length 프로퍼티를 포함하는지 여부를 확인하고 값 타입을 추출할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type AT = T['length' & keyof T]\n</span></code></pre><h1><span>Array와 Tuple의 length</span></h1><p><span>length 프로터피를 지닌 대표적인 객체 타입은 Array와 Tuple이 있다.\n(Tuple도 Array의 일종이지만, 타입스크립트 시스템에서 Array 타입과 뚜렷한 차이가 있다.)</span></p><p><span>우선 Tuple의 예시다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type ExampleA = A['length' & keyof A]\n\nconst example: Example[1, 2, 3] = 3\nconst example2: Example[1, 2, 3] = 1 // error!\n\n</span></code></pre><img src=\"https://velog.velcdn.com/images/flashsoon/post/cd875bb0-c76c-4d62-b616-0b087f75549a/image.png\" alt=\"undefined\" /><p><span>타입을 확인해보면 Tuple의 경우 length 프로퍼티에 대해 숫자형 리터럴을 반환한다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/56b09567-758d-47a7-b80f-d13aad58ccf3/image.png\" alt=\"undefined\" /><p><span>다음은 Array의 예시다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type ExampleA = A['length' & keyof A];\n\nconst arr = [1, 2, 3];\n\nconst example: Exampletypeof arr = 1;\n</span></code></pre><p><span>example의 타입은 숫자형 리터럴이 아닌, number 타입으로 정의된다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/fb0bd795-30b3-4d7d-89cd-d567124eef42/image.png\" alt=\"undefined\" /><h2><span>왜 이런 차이가 발생할까?</span></h2><p><span>타입스크립트 시스템에서 Tuple 타입의 가장 중요한 특징은, </span><strong><span>순서와 길이, 내부 요소의 타입이 모두 고정되어 있는 특별한 Array라는 점이다.</span></strong></p><p><a href=\"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types\"><span>https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types</span></a></p><blockquote class=\"notion-quote\"><span>A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.</span></blockquote><p><span>따라서 타입스크립트 시스템 상에서는 길이가 고정되어 있는 Tuple의 length는 숫자형 리터럴로, 길이가 고정되어 있지 않고 동적으로 길이가 달라지는 Array의 length는 number 타입으로 결정된다.</span></p><h2><span>번외) number와 숫자형 리터럴</span></h2><p><span>그렇다면 number는 숫자형 리터럴이 될 수 있을까?</span></p><p><span>아래의 R 타입을 확인해보면 never로 결정되는 것을 통해 알 수 있듯, number가 숫자형 리터럴보다 이미 더 큰 범주의 타입이기 때문에 number를 숫자형 리터럴로 extends할 수 없다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type R = number extends Example[1, 2, 3] ? number : never; // never\n\n// 아래의 타입 정의와 같다.\ntype R = number extends 3 ? 3 : never; // never\n</span></code></pre><img src=\"https://velog.velcdn.com/images/flashsoon/post/a783d94c-83ee-45cb-bb29-376fd2d87c45/image.png\" alt=\"undefined\" /><p><span>그렇다면 반대는 어떨까?</span></p><p><span>당연히 숫자형 리터럴은 number 타입보다 좁은 범주의 타입이기 때문에 extends가 가능하다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type ExampleA = A['length' & keyof A];\n\nconst arr = [1, 2, 3];\n\ntype R = 3 extends Exampletypeof arr ? number : never; // number\n\n// 아래의 타입 정의와 같다.\ntype R = 3 extends number ? number : never; // number\n</span></code></pre><h1><span>실제 사용 예시</span></h1><p><span>아래는 React에서 상태 관리 라이브러리로 널리 사용되는 </span><strong><span>zustand</span></strong><span>의 코드 예시이다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\"> type MutateS, Ms = number extends Ms['length' & keyof Ms]\n  ? S\n  : Ms extends []\n    ? S\n    : Ms extends [[infer Mi, infer Ma], ...infer Mrs]\n      ? MutateStoreMutatorsS, Ma[Mi & StoreMutatorIdentifier], Mrs\n      : never\n</span></code></pre><p><span>Mutate 타입은 두 가지 제네릭 타입을 받고 있는데, 그중 첫번째 분기 처리로 Ms 타입에 대해</span></p><ol><li value=\"1\"><span>length 프로퍼티를 가지는 타입인지?</span></li><li value=\"2\"><span>length 프로퍼티의 값 타입이 number 타입인지?\n를 체크하고 있다.</span></li></ol><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type MutateS, Ms = number extends Ms['length' & keyof Ms] ? ... : ...\n</span></code></pre>"}},"pageContext":{"id":"321643d1-dde4-5a8a-8ca0-bf75ca676c94","title":"[Typescript] Array와 Tuple의 length 타입 차이? + 제네릭 타입의 특정 프로퍼티 체크하는 방법","contentHtml":"<h1><span>TL;DR;</span></h1><ul><li><span>&와 keyof를 사용하여 타입의 특정 프로퍼티를 체크할 수 있다.</span></li><li><span>Array의 length는 number</span></li><li><span>Tuple의 length는 숫자형 리터럴</span></li></ul><h1><span>length 프로퍼티 체크</span></h1><p><span>제네릭 타입을 사용하는 중에 해당 타입의 특정 프로퍼티가 있는지를 체크하고 싶다면, & 인터섹션과 keyof를 활용하여 구현할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type AT = T['property' & keyof T]\n</span></code></pre><p><span>원리는 간단하다.</span></p><ol><li value=\"1\"><span>T 제네릭 타입에 keyof를 하면 </span><strong><span>T 타입의 프로퍼티가 유니온 타입으로 변환된다.</span></strong></li><li value=\"2\"><span data-right-bracket=\"true\">이 유니온 타입의 인터섹션을 내가 체크하고 싶은 프로퍼티 명으로 하면 해당 프로퍼티만 남는다. - </span><strong><span>만약 인터섹션이 되지 않으면 never 타입이 된다.</span></strong></li><li value=\"3\"><strong><span>2번에서 추출한 프로퍼티로 T 타입에 indexed access를 하여 해당 프로퍼티의 타입으로 최종 결정된다.</span></strong></li></ol><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type AT = T['property' & keyof T]\n\ntype Example = {'property': number, 'rest': string}\ntype Example2 = {a: number}\n\ntype Foo = AExample // number\n\ntype Bar = AExample2 // never\n\n</span></code></pre><p><span>위 예시에서 </span><code><span>Foo</span></code><span> 타입은</span></p><ol><li value=\"1\"><code><span data-left-bracket=\"true\" data-right-bracket=\"true\">AExample = Example['property' & keyof T]</span></code><span> 타입으로 정의된다.</span></li><li value=\"2\"><code><span>Example['property' & keyof T]</span></code><span> 는 </span><code><span>Example['property' & ('property' | 'rest')]</span></code><span>와 같다.</span></li><li value=\"3\"><span>Example 타입에는 </span><code><span>'property'</span></code><span> 프로퍼티 속성이 있으므로 해당 프로퍼티 속성의 타입이 인터섹션의 결과로 남는다.</span></li><li value=\"4\"><code><span>Example['property']</span></code><span>는 number 타입에 해당하므로 최종적으로 </span><code><span>Foo</span></code><span>는 number 타입으로 정의된다.</span></li></ol><p><span>이러한 원리를 이용하여 아래와 같이 T 제네릭 타입에 length 프로퍼티를 포함하는지 여부를 확인하고 값 타입을 추출할 수 있다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type AT = T['length' & keyof T]\n</span></code></pre><h1><span>Array와 Tuple의 length</span></h1><p><span>length 프로터피를 지닌 대표적인 객체 타입은 Array와 Tuple이 있다.\n(Tuple도 Array의 일종이지만, 타입스크립트 시스템에서 Array 타입과 뚜렷한 차이가 있다.)</span></p><p><span>우선 Tuple의 예시다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type ExampleA = A['length' & keyof A]\n\nconst example: Example[1, 2, 3] = 3\nconst example2: Example[1, 2, 3] = 1 // error!\n\n</span></code></pre><img src=\"https://velog.velcdn.com/images/flashsoon/post/cd875bb0-c76c-4d62-b616-0b087f75549a/image.png\" alt=\"undefined\" /><p><span>타입을 확인해보면 Tuple의 경우 length 프로퍼티에 대해 숫자형 리터럴을 반환한다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/56b09567-758d-47a7-b80f-d13aad58ccf3/image.png\" alt=\"undefined\" /><p><span>다음은 Array의 예시다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type ExampleA = A['length' & keyof A];\n\nconst arr = [1, 2, 3];\n\nconst example: Exampletypeof arr = 1;\n</span></code></pre><p><span>example의 타입은 숫자형 리터럴이 아닌, number 타입으로 정의된다.</span></p><img src=\"https://velog.velcdn.com/images/flashsoon/post/fb0bd795-30b3-4d7d-89cd-d567124eef42/image.png\" alt=\"undefined\" /><h2><span>왜 이런 차이가 발생할까?</span></h2><p><span>타입스크립트 시스템에서 Tuple 타입의 가장 중요한 특징은, </span><strong><span>순서와 길이, 내부 요소의 타입이 모두 고정되어 있는 특별한 Array라는 점이다.</span></strong></p><p><a href=\"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types\"><span>https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types</span></a></p><blockquote class=\"notion-quote\"><span>A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.</span></blockquote><p><span>따라서 타입스크립트 시스템 상에서는 길이가 고정되어 있는 Tuple의 length는 숫자형 리터럴로, 길이가 고정되어 있지 않고 동적으로 길이가 달라지는 Array의 length는 number 타입으로 결정된다.</span></p><h2><span>번외) number와 숫자형 리터럴</span></h2><p><span>그렇다면 number는 숫자형 리터럴이 될 수 있을까?</span></p><p><span>아래의 R 타입을 확인해보면 never로 결정되는 것을 통해 알 수 있듯, number가 숫자형 리터럴보다 이미 더 큰 범주의 타입이기 때문에 number를 숫자형 리터럴로 extends할 수 없다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type R = number extends Example[1, 2, 3] ? number : never; // never\n\n// 아래의 타입 정의와 같다.\ntype R = number extends 3 ? 3 : never; // never\n</span></code></pre><img src=\"https://velog.velcdn.com/images/flashsoon/post/a783d94c-83ee-45cb-bb29-376fd2d87c45/image.png\" alt=\"undefined\" /><p><span>그렇다면 반대는 어떨까?</span></p><p><span>당연히 숫자형 리터럴은 number 타입보다 좁은 범주의 타입이기 때문에 extends가 가능하다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type ExampleA = A['length' & keyof A];\n\nconst arr = [1, 2, 3];\n\ntype R = 3 extends Exampletypeof arr ? number : never; // number\n\n// 아래의 타입 정의와 같다.\ntype R = 3 extends number ? number : never; // number\n</span></code></pre><h1><span>실제 사용 예시</span></h1><p><span>아래는 React에서 상태 관리 라이브러리로 널리 사용되는 </span><strong><span>zustand</span></strong><span>의 코드 예시이다.</span></p><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\"> type MutateS, Ms = number extends Ms['length' & keyof Ms]\n  ? S\n  : Ms extends []\n    ? S\n    : Ms extends [[infer Mi, infer Ma], ...infer Mrs]\n      ? MutateStoreMutatorsS, Ma[Mi & StoreMutatorIdentifier], Mrs\n      : never\n</span></code></pre><p><span>Mutate 타입은 두 가지 제네릭 타입을 받고 있는데, 그중 첫번째 분기 처리로 Ms 타입에 대해</span></p><ol><li value=\"1\"><span>length 프로퍼티를 가지는 타입인지?</span></li><li value=\"2\"><span>length 프로퍼티의 값 타입이 number 타입인지?\n를 체크하고 있다.</span></li></ol><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">type MutateS, Ms = number extends Ms['length' & keyof Ms] ? ... : ...\n</span></code></pre>"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}