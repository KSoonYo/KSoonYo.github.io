{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/3a3ff7ad-af41-59ca-a864-08642c165f63/","result":{"data":{"site":{"siteMetadata":{"title":"KSoonYo Blog"}},"notionPage":{"title":"[React] CRA 없이 React 18 프로젝트 셋팅하기(with typescript)","contentHtml":"<p><strong><span>webpack5를 이용하여 react v18 + typescript 프로젝트 셋팅하는 방법 정리</span></strong><span>\n기본적인 셋팅 과정을 간략하게 정리한 글이므로 구체적인 설명은 생략</span></p><p></p><p><strong><span>패키지 매니저: yarn(classic)</span></strong><span>\nwhy? - npm과 더불어 가장 클래식한 패키지 매니저라고 생각하여 yarn classic으로 과정 정리</span></p><p></p><p><span>만약 이 글을 참고하신다면, 진행 중인 프로젝트의 성격에 맞게 Eslint, Prettier, typescript, babel 등 설정을 자유롭게 변경해주세요.</span></p><h1><span>과정</span></h1><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add react react-dom\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D webpack webpack-cli webpack-dev-server\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D babel-loader css-loader style-loader\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D babel-loader @babel/core @babel/preset-env @babel/preset-react babel-plugin-module-resolver\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D html-webpack-plugin clean-webpack-plugin speed-measure-webpack-plugin\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add --dev typescript ts-loader @types/react @types/react-dom @babel/preset-typescript\n</span></code></pre><pre class=\"language-json\"><code class=\"language-json\"><span>{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"jsx\": \"react-jsx\",\n    \"module\": \"ESNext\",\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"baseUrl\": \"src\",\n    \"moduleResolution\": \"node\",\n\t\t\"typeRoots\": [\"node_modules/@types\", \"src/types\"],\n    \"sourceMap\": true,\n    \"resolveJsonModule\": true,\n    \"types\": [\"node\"],\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n</span></code></pre><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>module.exports = {\n  presets: [\n    ['@babel/preset-react', { runtime: 'automatic' }],\n    '@babel/preset-env',\n    '@babel/preset-typescript',\n  ],\n  plugins: [\n    [\n      'module-resolver',\n      {\n        root: ['./src'],\n        extensions: ['.ts', '.tsx', ',json'],\n      },\n    ],\n  ],\n};\n\n</span></code></pre><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// App.tsx\nimport React from 'react';\n\nconst App: React.FC = () = {\n\treturn h1 Hello world! /h1\n}\n\nexport default App;\n</span></code></pre><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// index.tsx\n\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\n\nroot.render(App /);\n</span></code></pre><pre class=\"language-markup\"><code class=\"language-markup\"><!--<!DOCTYPE html>\n<html lang=\"ko\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta name=\"description\" content=\"react project\" />\n    <title>React Project</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n--></code></pre><p><span>예를 들어, dev server 옵션 설정은 개발 모드일 때 설정해주면 된다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'development', // or 'production'\n  entry: './src/index.tsx',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n       {\n          test: /\\.(tsx|ts|jsx|js)?$/,\n          exclude: /node_modules/,\n          use: [\n            'babel-loader',\n            {\n              loader: 'ts-loader',\n              options: {\n                transpileOnly: true,\n              },\n            },\n          ],\n      },\n      {\n        test: /\\.css$/, // CSS 파일에 대해 로더 사용\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js', '.jsx'],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html', // HTML 템플릿 설정\n    }),\n  ],\n  devServer: {\n    static: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n  },\n};\n</span></code></pre><pre class=\"language-json\"><code class=\"language-json\"><span>\"scripts\":{\n  \"dev\":\"webpack-dev-server --mode=development --config webpack.config.js --hot --progress\",\n  \"start\": \"webpack --mode=development --config webpack.config.js --progress\"\n}\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn dev\n</span></code></pre><h1><span>번외 1) eslint 설정</span></h1><li><code><span>eslint</span></code><span> 와 필요한 플러그인 설치</span><ul></ul></li><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D eslint eslint-config-airbnb eslint-config-airbnb-typescript eslint-config-prettier\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks\n\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D @types/eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser\n</span></code></pre><li><span>package.json에 eslintConfig 설정 추가</span><ul><pre class=\"language-json\"><code class=\"language-json\"><span>{\n  \"eslintConfig\": {\n    \"extends\": [\n      \"react-app\",\n      \"react-app/jest\"\n    ]\n  },\n}\n</span></code></pre><p><span>→ </span><code><span>react-app</span></code><span> 이 제공하는 기본 ESLint 규칙과 Jest 테스트를 위한 추가 규칙을 포함(extends) 하는 설정</span></p></ul></li><li><span>프로젝트 루트 파일에 </span><code><span>.eslintrc.json</span></code><span> 파일 생성(typescript 적용을 위해 **</span><code><span>tsconfig.json</span></code><span>*을 생성했다고 가정)</span><ul><pre class=\"language-json\"><code class=\"language-json\"><span>{\n  \"root\": true,\n  \"extends\": [\"airbnb-typescript\"],\n  \"plugins\": [\"@typescript-eslint\", \"prettier\", \"import\"],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"project\": \"./tsconfig.json\",\n    \"ecmaVersion\": 12,\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"sourceType\": \"module\"\n  },\n  \"rules\": {\n    \"no-useless-constructor\": \"off\",\n    \"import/no-extraneous-dependencies\": 0,\n    \"import/extensions\": [\"off\"],\n    \"import/order\": [\n      \"error\",\n      {\n        \"groups\": [\"builtin\", \"external\", \"internal\"],\n        \"pathGroups\": [\n          { \"pattern\": \"react\", \"group\": \"builtin\", \"position\": \"after\" },\n          { \"pattern\": \"react-dom\", \"group\": \"builtin\", \"position\": \"after\" }\n        ],\n        \"pathGroupsExcludedImportTypes\": [\"react\", \"react-dom\"],\n        \"alphabetize\": { \"order\": \"asc\", \"caseInsensitive\": true }\n      }\n    ],\n    \"@typescript-eslint/indent\": \"off\",\n    \"@typescript-eslint/comma-dangle\": \"off\",\n    \"react/jsx-filename-extension\": \"off\",\n    \"@typescript-eslint/no-useless-constructor\": \"off\",\n    \"@typescript-eslint/consistent-type-imports\": \"error\"\n  },\n  \"env\": {\n    \"jest\": true\n  }\n}\n\n</span></code></pre></ul></li><h1><span>번외 2) chunk hash 적용</span></h1><li><span>output 파일에 대한 캐싱 처리를 위해 filename과 chunkFilename에 hash를 설정할 수 있음</span><ul></ul></li><li><span>파일에 변경사항이 발생하면 번들링할 때 output의 filename hash를 다르게 적용 → </span><strong><span>브라우저가 변경된 파일에 대해서만 새로 다운로드하도록 성능을 개선할 수 있음(같은 file 명에 대해서는 브라우저가 캐싱)</span></strong><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.tsx',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].js', // 해시 포함\n    chunkFilename: '[name].[contenthash].js', // 청크 파일에도 해시 적용\n  },\n  // ...기타 설정\n};\n</span></code></pre><h1><span>번외 3) optimization - code spliting 적용</span></h1><li><strong><span>여러 파일에서 자주 사용되는 패키지의 경우에는 별도 chunk로 분리</span></strong><ul><li><span>초기 로딩 시 불필요한 코드 양을 줄이고 브라우저가 더 빠르게 어플리케이션을 로드 가능</span><ul></ul></li><li><span>잘 변경되지 않는 패키지에 대해 브라우저 캐싱을 하여 라이브러리를 업데이트하지 않는 한 해당 청크에 대해서 캐싱된 버전을 사용 → 다운로드 요청 수 최적화, 로딩 속도 개선</span><ul></ul></li><li><span>패키지의 버전이 변경되더라도 애플리케이션 코드와 분리되어 있기 때문에 패키지 관련 코드가 중복되지 않고 어플리케이션에 영향을 최소화할 수 있음</span><ul></ul></li></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>    optimization: {\n      splitChunks: {\n        cacheGroups: {\n          reactVendor: {\n            test: /[\\\\\\\\/]node_modules[\\\\\\\\/](react|react-dom|react-router-dom)[\\\\\\\\/]/,\n            name: 'vendor-react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n</span></code></pre><li><code><span>react</span></code><span> , </span><code><span>react-dom</span></code><span> , </span><code><span>react-router-dom</span></code><span> 패키지는 react 앱 프로젝트에서 필수로 사용되는 패키지</span><ul></ul></li><li><span>따라서 위와 같이 별도 청크로 분리해주면, 해당 청크가 필요한 시점에 로드되어 사용 → 번들링된 모듈에서 내에서 불필요한 중복 코드를 방지</span><ul></ul></li><h1><span>번외 4) </span><code><span>esbuild-loader</span></code><span> 와 </span><code><span>webpack5</span></code><span> 함께 쓰기</span></h1><p><a href=\"https://www.npmjs.com/package/esbuild-loader\"><span>https://www.npmjs.com/package/esbuild-loader</span></a></p><p><a href=\"https://fe-developers.kakaoent.com/2022/220707-webpack-esbuild-loader/\"><span>https://fe-developers.kakaoent.com/2022/220707-webpack-esbuild-loader/</span></a></p><p><a href=\"https://velog.io/@votogether2023/ts-loader%EB%A5%BC-esbuild-loader%EB%A1%9C-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98%ED%95%B4%EB%B3%B4%EC%9E%90\"><span>https://velog.io/@votogether2023/ts-loader를-esbuild-loader로-마이그레이션해보자</span></a></p><li><code><span>esbuild-loader</span></code><span> 설치</span><ul></ul></li><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D esbuild-loader\n</span></code></pre><li><code><span>esbuild-loader</span></code><span> 는 </span><code><span>babel-loader</span></code><span> 와 </span><code><span>ts-loader</span></code><span> 를 대체함</span><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>  module.exports = {\n      module: {\n          rules: [\n-             // Transpile JavaScript\n-             {\n-                 test: /\\\\.js$/,\n-                 use: 'babel-loader'\n-             },\n-\n-             // Compile TypeScript\n-             {\n-                 test: /\\\\.tsx?$/,\n-                 use: 'ts-loader'\n-             },\n+             // Use esbuild to compile JavaScript & TypeScript\n+             {\n+                 // Match `.js`, `.jsx`, `.ts` or `.tsx` files\n+                 test: /\\\\.[jt]sx?$/,\n+                 loader: 'esbuild-loader',\n+                 options: {\n+                     // JavaScript version to compile to\n+                     target: 'es2015'\n+                 }\n+             },\n\n              // Other rules...\n          ],\n      },\n  }\n</span></code></pre><img src=\"https://velog.velcdn.com/images/flashsoon/post/29a432c1-2668-4292-95d1-259e5e086776/image.png\" alt=\"undefined\" /><p></p><li><span>다만 </span><code><span>esbuild-loader</span></code><span>는 트랜스파일을 할 뿐, 타입 체킹을 하지 않기 때문에 별도의 플로그인으로 타입 체킹을 수행해야 함</span><ul></ul></li><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D fork-ts-checker-webpack-plugin\n</span></code></pre><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\n // ...\n\nmodule.exports = {\n // ... 생략 ...\n plugins: [\n      new ForkTsCheckerWebpackPlugin({\n        typescript: {\n          configFile: './tsconfig.json',\n        },\n      }),\n      // ...\n  ]\n}\n\n</span></code></pre><li><span>만약 production 모드 파일 압축을 webpack Terser 대신 Esbuild를 사용하고 싶다면, </span><code><strong><span>EsbuildPlugin</span></strong></code><strong><span> 을 minimizer로 설정해야 함</span></strong><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>+ const { EsbuildPlugin } = require('esbuild-loader')\n\n  module.exports = {\n\n+     optimization: {\n+         minimizer: [\n+             new EsbuildPlugin({\n+                 target: 'es2015'  // Syntax to transpile to (see options below for possible values)\n+\t\t\t\t          css: true,\n+             })\n+         ]\n+     },\n  }\n</span></code></pre>"}},"pageContext":{"id":"3a3ff7ad-af41-59ca-a864-08642c165f63","title":"[React] CRA 없이 React 18 프로젝트 셋팅하기(with typescript)","contentHtml":"<p><strong><span>webpack5를 이용하여 react v18 + typescript 프로젝트 셋팅하는 방법 정리</span></strong><span>\n기본적인 셋팅 과정을 간략하게 정리한 글이므로 구체적인 설명은 생략</span></p><p></p><p><strong><span>패키지 매니저: yarn(classic)</span></strong><span>\nwhy? - npm과 더불어 가장 클래식한 패키지 매니저라고 생각하여 yarn classic으로 과정 정리</span></p><p></p><p><span>만약 이 글을 참고하신다면, 진행 중인 프로젝트의 성격에 맞게 Eslint, Prettier, typescript, babel 등 설정을 자유롭게 변경해주세요.</span></p><h1><span>과정</span></h1><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add react react-dom\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D webpack webpack-cli webpack-dev-server\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D babel-loader css-loader style-loader\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D babel-loader @babel/core @babel/preset-env @babel/preset-react babel-plugin-module-resolver\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D html-webpack-plugin clean-webpack-plugin speed-measure-webpack-plugin\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add --dev typescript ts-loader @types/react @types/react-dom @babel/preset-typescript\n</span></code></pre><pre class=\"language-json\"><code class=\"language-json\"><span>{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"jsx\": \"react-jsx\",\n    \"module\": \"ESNext\",\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"baseUrl\": \"src\",\n    \"moduleResolution\": \"node\",\n\t\t\"typeRoots\": [\"node_modules/@types\", \"src/types\"],\n    \"sourceMap\": true,\n    \"resolveJsonModule\": true,\n    \"types\": [\"node\"],\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n</span></code></pre><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>module.exports = {\n  presets: [\n    ['@babel/preset-react', { runtime: 'automatic' }],\n    '@babel/preset-env',\n    '@babel/preset-typescript',\n  ],\n  plugins: [\n    [\n      'module-resolver',\n      {\n        root: ['./src'],\n        extensions: ['.ts', '.tsx', ',json'],\n      },\n    ],\n  ],\n};\n\n</span></code></pre><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// App.tsx\nimport React from 'react';\n\nconst App: React.FC = () = {\n\treturn h1 Hello world! /h1\n}\n\nexport default App;\n</span></code></pre><pre class=\"language-typescript\"><code class=\"language-typescript\"><span data-left-bracket=\"true\" data-right-bracket=\"true\">// index.tsx\n\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\n\nroot.render(App /);\n</span></code></pre><pre class=\"language-markup\"><code class=\"language-markup\"><!--<!DOCTYPE html>\n<html lang=\"ko\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta name=\"description\" content=\"react project\" />\n    <title>React Project</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n--></code></pre><p><span>예를 들어, dev server 옵션 설정은 개발 모드일 때 설정해주면 된다.</span></p><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'development', // or 'production'\n  entry: './src/index.tsx',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n       {\n          test: /\\.(tsx|ts|jsx|js)?$/,\n          exclude: /node_modules/,\n          use: [\n            'babel-loader',\n            {\n              loader: 'ts-loader',\n              options: {\n                transpileOnly: true,\n              },\n            },\n          ],\n      },\n      {\n        test: /\\.css$/, // CSS 파일에 대해 로더 사용\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js', '.jsx'],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html', // HTML 템플릿 설정\n    }),\n  ],\n  devServer: {\n    static: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n  },\n};\n</span></code></pre><pre class=\"language-json\"><code class=\"language-json\"><span>\"scripts\":{\n  \"dev\":\"webpack-dev-server --mode=development --config webpack.config.js --hot --progress\",\n  \"start\": \"webpack --mode=development --config webpack.config.js --progress\"\n}\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn dev\n</span></code></pre><h1><span>번외 1) eslint 설정</span></h1><li><code><span>eslint</span></code><span> 와 필요한 플러그인 설치</span><ul></ul></li><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D eslint eslint-config-airbnb eslint-config-airbnb-typescript eslint-config-prettier\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks\n\n</span></code></pre><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D @types/eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser\n</span></code></pre><li><span>package.json에 eslintConfig 설정 추가</span><ul><pre class=\"language-json\"><code class=\"language-json\"><span>{\n  \"eslintConfig\": {\n    \"extends\": [\n      \"react-app\",\n      \"react-app/jest\"\n    ]\n  },\n}\n</span></code></pre><p><span>→ </span><code><span>react-app</span></code><span> 이 제공하는 기본 ESLint 규칙과 Jest 테스트를 위한 추가 규칙을 포함(extends) 하는 설정</span></p></ul></li><li><span>프로젝트 루트 파일에 </span><code><span>.eslintrc.json</span></code><span> 파일 생성(typescript 적용을 위해 **</span><code><span>tsconfig.json</span></code><span>*을 생성했다고 가정)</span><ul><pre class=\"language-json\"><code class=\"language-json\"><span>{\n  \"root\": true,\n  \"extends\": [\"airbnb-typescript\"],\n  \"plugins\": [\"@typescript-eslint\", \"prettier\", \"import\"],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"project\": \"./tsconfig.json\",\n    \"ecmaVersion\": 12,\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"sourceType\": \"module\"\n  },\n  \"rules\": {\n    \"no-useless-constructor\": \"off\",\n    \"import/no-extraneous-dependencies\": 0,\n    \"import/extensions\": [\"off\"],\n    \"import/order\": [\n      \"error\",\n      {\n        \"groups\": [\"builtin\", \"external\", \"internal\"],\n        \"pathGroups\": [\n          { \"pattern\": \"react\", \"group\": \"builtin\", \"position\": \"after\" },\n          { \"pattern\": \"react-dom\", \"group\": \"builtin\", \"position\": \"after\" }\n        ],\n        \"pathGroupsExcludedImportTypes\": [\"react\", \"react-dom\"],\n        \"alphabetize\": { \"order\": \"asc\", \"caseInsensitive\": true }\n      }\n    ],\n    \"@typescript-eslint/indent\": \"off\",\n    \"@typescript-eslint/comma-dangle\": \"off\",\n    \"react/jsx-filename-extension\": \"off\",\n    \"@typescript-eslint/no-useless-constructor\": \"off\",\n    \"@typescript-eslint/consistent-type-imports\": \"error\"\n  },\n  \"env\": {\n    \"jest\": true\n  }\n}\n\n</span></code></pre></ul></li><h1><span>번외 2) chunk hash 적용</span></h1><li><span>output 파일에 대한 캐싱 처리를 위해 filename과 chunkFilename에 hash를 설정할 수 있음</span><ul></ul></li><li><span>파일에 변경사항이 발생하면 번들링할 때 output의 filename hash를 다르게 적용 → </span><strong><span>브라우저가 변경된 파일에 대해서만 새로 다운로드하도록 성능을 개선할 수 있음(같은 file 명에 대해서는 브라우저가 캐싱)</span></strong><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.tsx',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].js', // 해시 포함\n    chunkFilename: '[name].[contenthash].js', // 청크 파일에도 해시 적용\n  },\n  // ...기타 설정\n};\n</span></code></pre><h1><span>번외 3) optimization - code spliting 적용</span></h1><li><strong><span>여러 파일에서 자주 사용되는 패키지의 경우에는 별도 chunk로 분리</span></strong><ul><li><span>초기 로딩 시 불필요한 코드 양을 줄이고 브라우저가 더 빠르게 어플리케이션을 로드 가능</span><ul></ul></li><li><span>잘 변경되지 않는 패키지에 대해 브라우저 캐싱을 하여 라이브러리를 업데이트하지 않는 한 해당 청크에 대해서 캐싱된 버전을 사용 → 다운로드 요청 수 최적화, 로딩 속도 개선</span><ul></ul></li><li><span>패키지의 버전이 변경되더라도 애플리케이션 코드와 분리되어 있기 때문에 패키지 관련 코드가 중복되지 않고 어플리케이션에 영향을 최소화할 수 있음</span><ul></ul></li></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>    optimization: {\n      splitChunks: {\n        cacheGroups: {\n          reactVendor: {\n            test: /[\\\\\\\\/]node_modules[\\\\\\\\/](react|react-dom|react-router-dom)[\\\\\\\\/]/,\n            name: 'vendor-react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n</span></code></pre><li><code><span>react</span></code><span> , </span><code><span>react-dom</span></code><span> , </span><code><span>react-router-dom</span></code><span> 패키지는 react 앱 프로젝트에서 필수로 사용되는 패키지</span><ul></ul></li><li><span>따라서 위와 같이 별도 청크로 분리해주면, 해당 청크가 필요한 시점에 로드되어 사용 → 번들링된 모듈에서 내에서 불필요한 중복 코드를 방지</span><ul></ul></li><h1><span>번외 4) </span><code><span>esbuild-loader</span></code><span> 와 </span><code><span>webpack5</span></code><span> 함께 쓰기</span></h1><p><a href=\"https://www.npmjs.com/package/esbuild-loader\"><span>https://www.npmjs.com/package/esbuild-loader</span></a></p><p><a href=\"https://fe-developers.kakaoent.com/2022/220707-webpack-esbuild-loader/\"><span>https://fe-developers.kakaoent.com/2022/220707-webpack-esbuild-loader/</span></a></p><p><a href=\"https://velog.io/@votogether2023/ts-loader%EB%A5%BC-esbuild-loader%EB%A1%9C-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98%ED%95%B4%EB%B3%B4%EC%9E%90\"><span>https://velog.io/@votogether2023/ts-loader를-esbuild-loader로-마이그레이션해보자</span></a></p><li><code><span>esbuild-loader</span></code><span> 설치</span><ul></ul></li><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D esbuild-loader\n</span></code></pre><li><code><span>esbuild-loader</span></code><span> 는 </span><code><span>babel-loader</span></code><span> 와 </span><code><span>ts-loader</span></code><span> 를 대체함</span><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>  module.exports = {\n      module: {\n          rules: [\n-             // Transpile JavaScript\n-             {\n-                 test: /\\\\.js$/,\n-                 use: 'babel-loader'\n-             },\n-\n-             // Compile TypeScript\n-             {\n-                 test: /\\\\.tsx?$/,\n-                 use: 'ts-loader'\n-             },\n+             // Use esbuild to compile JavaScript & TypeScript\n+             {\n+                 // Match `.js`, `.jsx`, `.ts` or `.tsx` files\n+                 test: /\\\\.[jt]sx?$/,\n+                 loader: 'esbuild-loader',\n+                 options: {\n+                     // JavaScript version to compile to\n+                     target: 'es2015'\n+                 }\n+             },\n\n              // Other rules...\n          ],\n      },\n  }\n</span></code></pre><img src=\"https://velog.velcdn.com/images/flashsoon/post/29a432c1-2668-4292-95d1-259e5e086776/image.png\" alt=\"undefined\" /><p></p><li><span>다만 </span><code><span>esbuild-loader</span></code><span>는 트랜스파일을 할 뿐, 타입 체킹을 하지 않기 때문에 별도의 플로그인으로 타입 체킹을 수행해야 함</span><ul></ul></li><pre class=\"language-shell\"><code class=\"language-shell\"><span>yarn add -D fork-ts-checker-webpack-plugin\n</span></code></pre><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\n // ...\n\nmodule.exports = {\n // ... 생략 ...\n plugins: [\n      new ForkTsCheckerWebpackPlugin({\n        typescript: {\n          configFile: './tsconfig.json',\n        },\n      }),\n      // ...\n  ]\n}\n\n</span></code></pre><li><span>만약 production 모드 파일 압축을 webpack Terser 대신 Esbuild를 사용하고 싶다면, </span><code><strong><span>EsbuildPlugin</span></strong></code><strong><span> 을 minimizer로 설정해야 함</span></strong><ul></ul></li><pre class=\"language-javascript\"><code class=\"language-javascript\"><span>+ const { EsbuildPlugin } = require('esbuild-loader')\n\n  module.exports = {\n\n+     optimization: {\n+         minimizer: [\n+             new EsbuildPlugin({\n+                 target: 'es2015'  // Syntax to transpile to (see options below for possible values)\n+\t\t\t\t          css: true,\n+             })\n+         ]\n+     },\n  }\n</span></code></pre>"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}